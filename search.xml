<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/05/29/2023-5-21%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/29/2023-5-21%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="锁-《MySQL怎运》Ch22"><a href="#锁-《MySQL怎运》Ch22" class="headerlink" title="锁 《MySQL怎运》Ch22"></a>锁 《MySQL怎运》Ch22</h1><h2 id="22-1-解决并发事务带来问题的两种基本方式"><a href="#22-1-解决并发事务带来问题的两种基本方式" class="headerlink" title="22.1 解决并发事务带来问题的两种基本方式"></a>22.1 解决并发事务带来问题的两种基本方式</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>锁 《MySQL怎运》Ch22</title>
      <link href="/2023/01/29/2023-1-29%20%E9%94%81%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCh22/"/>
      <url>/2023/01/29/2023-1-29%20%E9%94%81%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCh22/</url>
      
        <content type="html"><![CDATA[<h1 id="锁-《MySQL怎运》Ch22"><a href="#锁-《MySQL怎运》Ch22" class="headerlink" title="锁 《MySQL怎运》Ch22"></a>锁 《MySQL怎运》Ch22</h1><h2 id="22-1-解决并发事务带来问题的两种基本方式"><a href="#22-1-解决并发事务带来问题的两种基本方式" class="headerlink" title="22.1 解决并发事务带来问题的两种基本方式"></a>22.1 解决并发事务带来问题的两种基本方式</h2><p>并发事务访问相同记录的情况大致可以划分为3中</p><ul><li>读 - 读情况：并发事务读取相同记录。没有影响</li><li>写 - 写情况：并发事务相继对相同记录进行改动</li><li>读 - 写或写 - 读情况：一个事务进行读取，另一个事务进行改动</li></ul><h3 id="22-1-1-写-写情况"><a href="#22-1-1-写-写情况" class="headerlink" title="22.1.1 写 - 写情况"></a>22.1.1 写 - 写情况</h3><p>在写 - 写的情况下会发生脏读，但是所有的隔离级别都会避免这个现象发生。所以在多个未提交事务同时对同一条记录进行改动时，需要排队执行。这个过程是通过对记录加锁实现的。</p><p>当一个事务希望改动记录时，首先会看内存中有没有这条记录关联的锁结构。如果每一有，就会在内存中生成锁结构进行关联。</p><p>锁结构最重要的两个信息</p><ul><li>trx信息：表示这个锁结构是与那个事务关联的</li><li>is_waiting：表示当前事务是否在等待</li></ul><p>当一个事务修改一条记录的时候，如果没有锁结构，则生成一个锁结构，设置is_waiting为false</p><p>当另外一个事务希望修改这条记录，发现已经存在锁结构，再生成一个锁结构，不过锁的is_waiting属性为true，表示需要等待</p><p>当第一个事务提交之后，将它关联的锁结构释放，检测与该记录相关的锁结构，如果还有其他锁结构，将其中一个的is_waiting属性设置为false，同时唤醒该事务对应的线程</p><p>几种说法：</p><ul><li>获取锁成功：在内存中生成对应的锁结构，并且锁结构is_waiting属性为false，事务可以继续操作。（不过之后存在隐式锁的说法）</li><li>获取锁失败：在内存中生成对应的锁结构，不过锁结构is_waiting属性为true，事务需要等待，不可以继续执行操作</li><li>不加锁：不需要在内存中生成锁结构，可以直接操作。不包括为记录加隐式锁</li></ul><h3 id="22-1-2-读-写或写-读情况"><a href="#22-1-2-读-写或写-读情况" class="headerlink" title="22.1.2 读 - 写或写 - 读情况"></a>22.1.2 读 - 写或写 - 读情况</h3><p>MySQL与SQL标准不同的一点是，MySQL在REPEATABLE READ隔离级别下很大程度避免了幻读现象。如何避免脏读、不可重复读、幻读现象，有两种可选的解决方案</p><ol><li>读操作使用MVCC，写操作进行加锁</li></ol><p>查询只能读取到ReadView之前已经提交事务的所做的更改；而写操作是针对最新版本的记录。</p><ol><li>读、写操作都使用加锁的方式</li></ol><p>一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本。这意味着读写操作都需要排队操作</p><p>使用MVCC的方式，读写操作彼此不冲突，性能更高；加锁的方式，读 - 写需要排队执行，影响性能。</p><h3 id="22-1-3-一致性读"><a href="#22-1-3-一致性读" class="headerlink" title="22.1.3 一致性读"></a>22.1.3 一致性读</h3><p>事务利用MVCC进行的读取操作称为一致性读，或者一致性无锁读。所有普通SELECT语句在READ COMMITTED、REPEATABLE READ 隔离级别下都算是一致性读。</p><p>一致性读并不会对表中任何记录进行加锁操作，其他事务可以自由地对表中的记录进行改动。</p><h3 id="22-1-4-锁定读"><a href="#22-1-4-锁定读" class="headerlink" title="22.1.4 锁定读"></a>22.1.4 锁定读</h3><ol><li><strong>共享锁和独占锁</strong></li></ol><p>在使用加锁的方式解决，由于既要允许读 - 读情况不受影响，又要使写 - 写、写 - 读、读- 写当中的操作互相阻塞，MySQL设计了两种锁</p><ul><li>共享锁（Shared Lock）：简称S锁。在事务读取一条记录时，需要先获取该记录的S锁</li><li>独占锁（Exclusive Lock）：常称为排他锁，简称X锁。事务需要改动一条记录的时候，需要先获取该记录的X锁</li></ul><p>当事务T1首先获取一条记录的S锁，之后T2也要访问这条记录：</p><ul><li>如果T2想要再获取一条记录的S锁，那么事务T2也会获得该锁，意味着T1和T2在该记录上同时拥有S锁</li><li>如哦T2想要获取一条记录的X锁，此操作会阻塞，知道T1提交之后将S锁释放位置</li></ul><p>所以S锁和S锁是互相兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容的</p><ol><li><strong>锁定读的语句</strong></li></ol><p>有时候需要在获取记录时候获取记录的X锁，禁止其他事务读写该记录，MySQL提供两种语句</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code>对读取的记录加S锁</li><li><code>SELECT ... FOR UPDATE</code> 对读取记录加X锁</li></ul><h2 id="22-2-多粒度锁"><a href="#22-2-多粒度锁" class="headerlink" title="22.2 多粒度锁"></a>22.2 多粒度锁</h2><p>之前提到的锁是对于记录的，称为行级锁或者行锁。事务同时也可以在表级别枷锁。称为表级锁或表锁。对于一个表加锁会影响表中的所有记录</p><ul><li>给表加S锁</li></ul><p>如果一个事务给表加了S锁，那么：</p><ul><li><ul><li>别的事务可以获得表的S锁</li><li>别的事务可以获得表中记录的S锁</li><li>别的事务不可以获得表的X锁</li><li>别的事务不可以获得表中记录的X锁</li></ul></li><li><p>给表加X锁</p></li><li><ul><li>别的事务不可以获得表的S锁</li><li>别的事务不可以获得表中记录的S锁</li><li>别的事务不可以获得表的X锁</li><li>别的事务不可以获得表中记录的X锁</li></ul></li></ul><p>给表加锁存在两个问题：</p><ul><li>如果对表整体上S锁，如果表中有X锁，需要表中所有记录的X锁都释放了才能上S锁</li><li>如果对表整体上X锁，需要等表中所有记录的X锁和S锁都释放了才能上X锁</li></ul><p>因此，InnoDB设计了称为意向锁的东西</p><ul><li>意向共享锁（Intention Shared Lock）：简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加上一个IS锁</li><li>意向独占锁（Intention Exclusive Lock）：简称IX锁。当事务准备准备在某条记录上加X锁时候，需要现在表级别加上一个IX锁</li></ul><p>之后对于表加锁的时候，只需要看表是否存在意向锁，即可知道表中的记录是否全部被释放</p><h2 id="22-3-MySQL中的行锁和表锁"><a href="#22-3-MySQL中的行锁和表锁" class="headerlink" title="22.3 MySQL中的行锁和表锁"></a>22.3 MySQL中的行锁和表锁</h2><h3 id="22-3-1-其他存储引擎中的锁"><a href="#22-3-1-其他存储引擎中的锁" class="headerlink" title="22.3.1 其他存储引擎中的锁"></a>22.3.1 其他存储引擎中的锁</h3><p>对于MyISAM、MEMORY、MERGE这些存储引擎来说，它们只支持表级锁，而且这些存储引擎并不支持事务。</p><h3 id="22-3-2-InnoDB存储引擎中的锁"><a href="#22-3-2-InnoDB存储引擎中的锁" class="headerlink" title="22.3.2 InnoDB存储引擎中的锁"></a>22.3.2 InnoDB存储引擎中的锁</h3><p>InnoDB存储引擎既支持表级锁，也支持行级锁。表级锁粒度粗，占用资源较少；行级锁粒度细，可以实现更精准的并发控制，但是占用资源较多。</p><ol><li><strong>InnoDB中的表级锁</strong></li></ol><p>一般情况下，不会用到存储引擎提供是表级S锁或X锁</p><ul><li><code>LOCK TABLE t READ</code>：存储引擎会对表t加上表级别S锁</li><li><code>LOCK TABLE t WRITE</code>：存储引擎会对表t加上表级别X锁</li></ul><p><strong>表级别的AUTO-INC锁</strong></p><p>使用MySQL可以为某个列添加AUTO_INCREMENT属性，之后插入记录时，系统会自动为它赋予递增的值。系统自动给AUTH_INCREMENT修饰的列进行递增赋值的实现方式主要有下面两个</p><ul><li>采用AUTH-INC锁，就是在执行插入语句的时候加一个表级别的AUTO-INC锁，在语句结束时候释放AUTO-INC锁</li><li>采用一个轻量级的锁，在生成本次语句需要用到的AUTO_INCREMENT修饰的列的值之后，释放该轻量级锁</li></ul><ol><li><strong>InnoDB中的行级锁</strong></li></ol><p>下面是常见的行级锁类型</p><ul><li><strong>Record Lock</strong></li></ul><p>仅仅把一条记录锁上。同时有S锁和X锁之分</p><ul><li><strong>Gap Lock</strong></li></ul><p>因为幻影记录在插入前不存在，没有办法使用Record锁</p><p>用于防止插入幻影记录，GAP锁有一个范围，例如一个区间(3, 8)的gap锁，则在(3,8)记录中插入记录的操作会被阻塞</p><ul><li><strong>Next-Key Lock</strong></li></ul><p>同时锁住某一条记录，同时又组织其他事务在该记录前面的间隙插入新记录</p><ul><li><strong>Insert Intention Lock</strong></li></ul><p>一个事务插入一条记录，在插入位置已经被加上Gap锁，事务需要等待。在等待期间需要在内存生成一个锁结构，表明有意向在某个间隙插入新记录。</p><p>&#x2F;&#x2F; 没懂这个锁的功能</p><ul><li><strong>隐式锁</strong></li></ul><p>生成并维护锁结构并不是一件零成本的事情。所以InnoDB又一个隐式锁的概念</p><p>在一个事务中首先INSERT了一条记录，然后另外一个事务执行后续操作，读取这条记录并加上X锁或者S锁</p><p>如果允许这种场景出现，可能会出现脏读现象，因为后续事务可能立即修改这条记录，因此，这时候InnoDB会有下面这种情景</p><ul><li><ul><li>对于聚簇索引，有一个trx_id隐藏列，如果其他事务想要对于这个记录添加锁，会看一下记录的trx_id是否是当前的活跃事务，如果是，则帮助该事务创建一个X锁的锁结构，is_waiting为false，为自己创建一个锁结构，is_waiting为true</li><li>对于二级索引，本身没有trx_id，但是判断PAGE_MAX_TRX_ID属性，如果不小于当前最小活跃事务id，需要回表查找聚簇索引记录，然后重复</li></ul></li></ul><p>因此，一个事务对于新插入的记录可以不显式地加锁，但是由于trx_id的存在，相当于加上了一个隐式锁，起到了延迟生成锁结构的用处。当其他事务不涉及与该记录冲突的时候，就可以避免生成锁结构。</p><h2 id="22-4-语句加锁分析"><a href="#22-4-语句加锁分析" class="headerlink" title="22.4 语句加锁分析"></a>22.4 语句加锁分析</h2><p>方便期间，语句分为4大类：普通的SELECT语句、锁定读的语句、半一致性读的语句以及INSERT语句。</p><h3 id="22-4-1-普通的SELECT语句"><a href="#22-4-1-普通的SELECT语句" class="headerlink" title="22.4.1 普通的SELECT语句"></a>22.4.1 普通的SELECT语句</h3><p>在不同的隔离级别下，普通的SELECT语句具有不同的表现:</p><ul><li>在READ UNCOMMITTED隔离级别下，不加锁，直接读取记录的最新版本，可能出现脏读、不可重复读和幻读现象。</li><li>在READ COMMITTED隔离级别下，不加锁；在每次执行普通的SELECT语句时都会生成一个ReadView，避免了脏读现象，没有避免不可重复读和幻读现象。</li><li>在REPEATABLE READ隔离级别下，不加锁；只在第一次执行普通的SELECT语句时生成一个ReadVIew，避免了脏读、不可重复读和幻读现象</li></ul><p>特殊：</p><p>在REPEATABLE READ隔离级别下，T1第一次执行普通的SELECT语句时生成了一个ReadView，之后T2向表中插入了一条数据并提交。ReadView并不能组织T1执行UPDATE或DELETE语句来改动这个新插入的记录。这之后，该条记录的trx_id就变成了T1的事务id，之后就可以产看到这台记录。所以说，REPEATABLE READ不能完全禁止幻读</p><h3 id="22-4-1-锁定读的语句"><a href="#22-4-1-锁定读的语句" class="headerlink" title="22.4.1 锁定读的语句"></a>22.4.1 锁定读的语句</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 事务 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务隔离级别和MVCC 《MySQL怎运》ch21</title>
      <link href="/2023/01/02/2023-1-2%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8Bch21/"/>
      <url>/2023/01/02/2023-1-2%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8Bch21/</url>
      
        <content type="html"><![CDATA[<h1 id="事务隔离级别和MVCC-《MySQL怎运》ch21"><a href="#事务隔离级别和MVCC-《MySQL怎运》ch21" class="headerlink" title="事务隔离级别和MVCC 《MySQL怎运》ch21"></a>事务隔离级别和MVCC 《MySQL怎运》ch21</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="21-2-事务隔离级别"><a href="#21-2-事务隔离级别" class="headerlink" title="21.2 事务隔离级别"></a>21.2 事务隔离级别</h2><p>MySQL是一个客户端&#x2F;服务器架构的软件。对于一个服务器，可以有多个客户端与之链接。服务器可以同时处理来自多个客户端的多个事务。</p><p>在多个事务并发执行的时候，如果并发的事务执行访问到相同的数据，可能会引发一致性问题。这就希望事务隔离的执行，互不干涉。</p><p>最简单的方式就是让多个事务串行执行，即在系统同一时刻只能由一个事务运行。这种方式会严重降低系统吞吐量。所以通常会采取“舍弃一部分隔离性来换取一部分性能”</p><p>而如果将多个事务不进行可串行话执行的情况下，会出现这些一致性问题。</p><h3 id="21-2-1-事务并发执行时遇到的一致性问题"><a href="#21-2-1-事务并发执行时遇到的一致性问题" class="headerlink" title="21.2.1 事务并发执行时遇到的一致性问题"></a>21.2.1 事务并发执行时遇到的一致性问题</h3><ul><li>脏写</li></ul><p>如果一个事务修改了另一个未提交事务修改过的数据，意味着发生了脏写现象。脏写现象可能引发一致性问题，也可能破坏原子性和持久性。</p><ul><li>脏读</li></ul><p>如果一个事务读到了另一个未提交事务修改过的数据，就意味着发生了脏读现象。</p><ul><li>不可重复读</li></ul><p>如果一个事务修改了另一个未提交事务读取的数据，就意味着发生了不可重复读现象。</p><ul><li>幻读</li></ul><p>如果一个事务先根据某些条件查询一些记录，在事务未提交时，另一个事务写入了符合搜索条件的数据，意味着发生了幻读现象</p><h3 id="21-2-2-SQL标准中的4中隔离级别"><a href="#21-2-2-SQL标准中的4中隔离级别" class="headerlink" title="21.2.2 SQL标准中的4中隔离级别"></a>21.2.2 SQL标准中的4中隔离级别</h3><p>如果按照可能导致数据一致性问题的严重性给前面现象排序：</p><p><em>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</em></p><p>SQL标准中设立了4个隔离级别</p><ul><li>READ UNCOMMITED: 未提交读</li><li>READ COMMITTED: 已提交读</li><li>REPEATABLE READ: 可重复读</li><li>SERIALIZABLE: 可串行化</li></ul><p>SQL标准中固定：针对不同的隔离级别，并发执行过程中可以发生不同的现象：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITED</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>READ COMMITTED</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>REPEATABLE READ</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>SERIALIZABLE</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p> 因为脏写现象影响太严重了，所以无论哪种隔离级别都不允许脏写发生</p><h3 id="21-2-3-MySQL中支持的4种隔离级别"><a href="#21-2-3-MySQL中支持的4种隔离级别" class="headerlink" title="21.2.3 MySQL中支持的4种隔离级别"></a>21.2.3 MySQL中支持的4种隔离级别</h3><p>MySQL支持4中隔离级别，但是规定有一些出入</p><p>MySQL的默认隔离级别未REPEATABLE READ</p><p><strong>设置事务的隔离级别</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span> [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL <span class="variable">$level</span>;</span><br></pre></td></tr></table></figure><p>如果在SET关键字后面什么都不放，则只对执行SET语句之后的下一个事务产生影响。</p><p>可以在服务器启动的时候，修改启动选项transaction-isolation的值</p><p>可以查看系统变量确定当前会话默认的隔离级别<code>SHOW VARIABLES LIKE &#39;transaction_isolation&#39;</code></p><h2 id="21-3-MVCC原理"><a href="#21-3-MVCC原理" class="headerlink" title="21.3 MVCC原理"></a>21.3 MVCC原理</h2><h3 id="21-3-1-版本链"><a href="#21-3-1-版本链" class="headerlink" title="21.3.1 版本链"></a>21.3.1 版本链</h3><p>对于InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</p><ul><li>trx_id：一个事务每次对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中。这个隐藏列相当于一个指针，可以通过它找到该记录修改前的信息。</li></ul><p>每次对于i记录继续进行一次改动，都会记录一条undo日志。每条undo日志也都有一个roll_pointer属性，指向早一次的改动，通过这个属性可以将undo日志串成一个链表。这个链表被称为版本链。版本链的头节点就是当前记录的最新值，另外，每个版本中还半酣生成该版本时候对应的事务id。</p><p>MySQL会利用这个记录的版本链来控制并发事务访问相同记录时的行为，这种机制被称为多版本并发控制（Multi-Version-Concurrency Control，MVCC）</p><h3 id="21-3-2-ReadView"><a href="#21-3-2-ReadView" class="headerlink" title="21.3.2 ReadView"></a>21.3.2 ReadView</h3><p>对于不同事务隔离的核心问题时：需要判断版本链中哪个版本是当前事务可见的。因此InnoDB提出了ReadView（可翻译未“一致性视图”）的概念。ReadView中主要包含4个比较重要的内容</p><ul><li>m_ids：在生成ReadView时，当前系统中活跃的读写事务的事务id列表</li><li>min_trx_id：在生成ReadView时，当先系统中活跃的读写事务中最小的事务id；m_ids中的最小值</li><li>max_trx_id：在生成ReadView时，系统应该分配给下一个事务的事务id值</li><li>creator_trx_id：生成ReadView的事务的事务id</li></ul><p>在有了ReadView之后，在访问某条记录时，只需要按照一定的步骤来判断记录的某个版本是否可见</p><ul><li>如果访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问自己修改过的记录</li><li>如果访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务在生成ReadView之前那已经提交，该版本可以被访问</li><li>如果访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务在生成ReadView之后才开启，该版本不可以被当前事务访问</li><li>如果访问版本的trx_id属性值在ReadView中的max_trx_id值和min_trx_id之间，需要判断trx_id属性是否在m_ids列表中，如果在，则事务还是活跃的，不可以访问版本；反之可以访问版本</li></ul><p>MySQL中，READ COMMITTED与REPEATABLE READ隔离级别之间的一个区别就是在生成ReadView的时机不同。</p><ol><li>READ COMMITTED——每次读取数据前都生成一个ReadView</li></ol><p>在这个隔离级别下，每次读取数据前都会生成一个ReadView，意味着所有没有活跃的事务的数据，都不能在这个隔离级别下被执行看见</p><ol><li>REPEATABLE READ——在第一次读取数据时生成一个ReadView</li></ol><p>在这个隔离级别下，只有第一次读取时候会生成一个ReadView，意味着在事务执行期间发生的数据变化不会被事务看见</p><h3 id="21-3-3-二级索引与MVCC"><a href="#21-3-3-二级索引与MVCC" class="headerlink" title="21.3.3 二级索引与MVCC"></a>21.3.3 二级索引与MVCC</h3><p>trx_id和roll_pointer隐藏列，只在聚簇索引中才有，当使用二级索引进行查询的时候，大致分为两部</p><ol><li>二级索引页面的page Header存有一个PAGE_MAX_TRX_ID的属性，保存对于当前页面数据进行增删改操作的事务id。当SELECT语句访问二级索引的时候，ReadView中的min_trx_id如果大于该页面的PAGE_MAX_TRX_ID属性值，则该页面所有数据对ReadView可见</li><li>如果不能判别的情况下，使用索引记录中的主键值进行回表操作，得到对应的聚簇索引记录，再按照之前的方式查找可见版本</li></ol><h2 id="21-4-关于purge"><a href="#21-4-关于purge" class="headerlink" title="21.4 关于purge"></a>21.4 关于purge</h2><p>由两个内容</p><ol><li>insert undo日志再事务提交之后就可以释放，但update undo日志由于需要支持MVCC，不能立即删除</li><li>为了支持MVCC，delete mark操作仅仅是在记录上打一个删除标记，并没有将记录删除</li></ol><p>但是这两部分数据不能一直保存，需要在合适的时候彻底删除掉，这个删除操作称为purge</p><p>合适的删除undo日志的时间，就是系统中的ReadVIew不在访问这个事务的时候，即所有的ReadView不需要访问这个事务相关的时候。</p><p>InnoDB将当前系统中所有的ReadView按照创建时间连成了一个链表，当执行purge操作（后台单独线程执行）时候，就拿出最早的ReadView，然后，如果undo日志的事务no小于当前系统最早的ReadView的事务no，则该组undo日志和对应的标记为删除的记录彻底删除</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 事务 </tag>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>undo 日志 《MySQL怎运ch20》</title>
      <link href="/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/"/>
      <url>/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="undo-日志-《MySQL怎运ch20》"><a href="#undo-日志-《MySQL怎运ch20》" class="headerlink" title="undo 日志 《MySQL怎运ch20》"></a>undo 日志 《MySQL怎运ch20》</h1><h2 id="20-1-事务回滚的需求"><a href="#20-1-事务回滚的需求" class="headerlink" title="20.1 事务回滚的需求"></a>20.1 事务回滚的需求</h2><p>在事务执行到一半时候会出现一些情况：</p><ul><li>事务执行过程中遇到的错误，比如服务器的错误</li><li>手动输入ROLLBACK语句结束当前事务的执行</li></ul><p>以上两种情况会导致事务执行到一般就结束，但是事务在执行过程中可能已经修改了很多东西，为了保证事务的原子性，需要修改回事务执行之前的样子，这个过程称为回滚。</p><p>每当我们对一条记录进行改动（INSERT，DELETE，UPDATE）时候，需要把回滚时候需要的东西都记录下来。</p><p>由于查询操作并不会修改任何用户记录，所以在执行查询操作时，并不需要记录相应的undo日志。</p><h2 id="20-2-事务id"><a href="#20-2-事务id" class="headerlink" title="20.2 事务id"></a>20.2 事务id</h2><h3 id="20-2-1-分配事务id的时机"><a href="#20-2-1-分配事务id的时机" class="headerlink" title="20.2.1 分配事务id的时机"></a>20.2.1 分配事务id的时机</h3><p>一个事务可以是一个只读事务，也可以是一个读写事务。</p><p>如果某个事务在执行过程中对于某个表执行了增删改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id，分配过程如下。</p><ul><li>对于只读事务来说，只有在第一此对于某个用户创建临时表执行增删改操作时，才会为这个事务分配一个事务id，否则是不分配事务id的</li><li>对于读写事务来说，只有在第一次对于某个表（包括用户创建的临时表）执行增删改操作时，才会为这个事务分配一个事务id，否则是不分配事务id的。</li></ul><h3 id="20-2-2-事务id是怎么生成的"><a href="#20-2-2-事务id是怎么生成的" class="headerlink" title="20.2.2 事务id是怎么生成的"></a>20.2.2 事务id是怎么生成的</h3><p>事务id本质是一个数字，分配策略与隐藏的列row_id分配策略大致相同</p><ul><li>服务器在内存中维护一个全局变量，每当需要为某个事务分配id时，就会把变量的值当作事务id分配给该事务，并且把变量自增1</li><li>当变量的值为256的倍数时，就会将该变量的值刷新到系统表空间中页号为5的页面中一个名为Max Trx ID的属性中去，这个属性占用8字节的存储空间。</li><li>当系统下一次重新启动时，会将这个Max Trx ID属性加载到内存中，将该值加上256之后赋值给前面提到的全局变量。</li></ul><p>保证系统分配的事务id值是一个递增的数字。先分配事务id的事务得到的是较小的事务id，后分配的是较大的事务id</p><h3 id="20-2-3-trx-id隐藏列"><a href="#20-2-3-trx-id隐藏列" class="headerlink" title="20.2.3 trx_id隐藏列"></a>20.2.3 trx_id隐藏列</h3><p>聚簇索引的记录除了会保存完整的用户数据以外，还会自动添加trx_id、roll_pointer的隐藏列。</p><h2 id="20-3-undo日志的格式"><a href="#20-3-undo日志的格式" class="headerlink" title="20.3 undo日志的格式"></a>20.3 undo日志的格式</h2><p>一般每对一条记录进行一次改动，就对应一条undo日志。但在某些更新记录的操作中，也可能对应着两条undo日志。</p><h3 id="20-3-1-INSERT操作对应的undo日志"><a href="#20-3-1-INSERT操作对应的undo日志" class="headerlink" title="20.3.1 INSERT操作对应的undo日志"></a>20.3.1 INSERT操作对应的undo日志</h3><p>当向表中插入一条记录的时候会有乐观插入和悲观插入的区分，但是导致的结果都是这条记录被放到了一个数据页中。如果回滚这个操作日志，那么就需要删除这条记录。在写对应的undo日志时候，只要把这条记录的主键信息记录下来就行，InnoDB设计了一个类型为TRX_UNDO_INSERT_REC的undo日志，完整结构如图：</p><p><img src="/xkond/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/1672062045371-5421521b-9e79-4616-9b22-6734e25f05b1.png" alt="img"></p><ul><li>undo no在一个事务中是从0开始递增的。事务没提交，每生成一条undo日志，该条日志的undo no就增1</li><li>如果记录中的主键只包含一列，那么在类型为TRX_UNDO_INSERT_REC的undo日志中，只需要把该列占用的存储空间大小和真实值记录下来，如果主键包含多个列，那么每个列占用的存储空间和对应值都需要记录下来</li><li>roll_pointer字段，本质上就是一个指向记录对应的undo日志的指针</li></ul><h3 id="20-3-2-DELETE操作对应的undo日志"><a href="#20-3-2-DELETE操作对应的undo日志" class="headerlink" title="20.3.2 DELETE操作对应的undo日志"></a>20.3.2 DELETE操作对应的undo日志</h3><p>被删除的记录也会根据记录头信息中的next_record属性组成一个链表，这个链表页被称为垃圾链表。Page Header部分中有一个名为PAGE_FREE的属性指向垃圾链表的头节点。</p><p>当一个事务执行删除记录的操作的时候，需要经历两个阶段</p><ul><li>阶段1（delete mark阶段）：仅仅将记录的deleted_flag标识位设置为1，其他的不做修改，同时也没有加入垃圾链表</li><li>阶段2：在该删除语句的事务提交之后，这条记录从正常记录链表中删去，加入垃圾链表</li></ul><p> 对于此种类型，InnoDB设计了一种名为TRX_UNDO_DEL_MARK_REC类型的undo日志，完整结构如下</p><p><img src="/xkond/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/1672062213910-49c9c54d-7e0b-4ba4-8f60-e5a78d818022.png" alt="img"></p><h3 id="20-3-3-UPDATE操作对应的undo日志"><a href="#20-3-3-UPDATE操作对应的undo日志" class="headerlink" title="20.3.3 UPDATE操作对应的undo日志"></a>20.3.3 UPDATE操作对应的undo日志</h3><p>在执行UPDATE语句时候，innodb对更新主键和不更新主键两种情况提供不同的处理方案</p><ol><li>不更新主键</li></ol><p>在不更新主键的情况下，又可以细分为列占用的存储空间不发生变化和发生变化两种情况</p><ul><li>就地更新<br>对于更新记录时候，对于更新的每个列来说，更新后的列与更新前的列占用的存储空间一样大，可以进行就地更新。</li><li>先删除旧记录，再插入新记录<br>如果被更新的列在更新前和更新后占用的大小不一致，那么就需要先把这条就记录从聚簇索引中删除，然后创建新的记录插入页面中。</li></ul><p>对于不更新主键的情况，InnoDB设计了TRX_UNDO_UPD_EXIST_REC的undo日志类型</p><p><img src="/xkond/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/1672062253713-1087bed7-7c9f-4f66-ae34-029109762d1d.png" alt="img"></p><ol><li>更新主键</li></ol><p>更新记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变。针对这种情况，InnoDB在聚簇索引中分了两步进行处理</p><ul><li>步骤1：将旧记录继续delete mark操作，就是将记录的deleted_flag标识位置设置为1</li><li>步骤2：根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中</li></ul><p>对于这种情况，首先进行步骤1的时候，会记录一条类型为TRX_UNDO_DEL_MARK_REC的undo日志，之后插入新记录时，会记录一条类型为TRX_UNDO_INSERT_REC的undo日志</p><p><img src="/xkond/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/1672062290634-981ee3d8-57c9-4c93-8a25-1d64ba046094.png" alt="img"></p><h3 id="20-3-4-增删改操作对二级索引的影响"><a href="#20-3-4-增删改操作对二级索引的影响" class="headerlink" title="20.3.4 增删改操作对二级索引的影响"></a>20.3.4 增删改操作对二级索引的影响</h3><p>如果更新操作不涉及二级索引的列，则不记录操作</p><p>如果涉及到了二级索引键值的更新，意味着进行下面两个操作</p><ul><li>对旧的耳机索引记录执行delete mark操作</li><li>根据更新后的值创建一条新的二级索引记录</li></ul><h2 id="20-4-通用链表结构"><a href="#20-4-通用链表结构" class="headerlink" title="20.4 通用链表结构"></a>20.4 通用链表结构</h2><p>略</p><h2 id="20-5-FIL-PAGE-UNDO-LOG页面"><a href="#20-5-FIL-PAGE-UNDO-LOG页面" class="headerlink" title="20.5 FIL_PAGE_UNDO_LOG页面"></a>20.5 FIL_PAGE_UNDO_LOG页面</h2><p>表空间中有一种名为FIL_PAGE_UNDO_LOG类型的页面专门用来存储undo日志的。</p><p><img src="/xkond/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/1672062350280-010a0d0e-defe-4b5c-852f-e5c644b7d3a0.png" alt="img"></p><p>其中Undo Page Header是Undo页面特有的</p><p><img src="/xkond/2023/01/01/2023-1-1%20undo%20%E6%97%A5%E5%BF%97%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90ch20%E3%80%8B/1672062328379-4dd481da-43da-45fd-8dfc-49a6b2c39188.png" alt="img"></p><p>各个属性如下</p><ul><li><p>TRX_UNDO_PAGE_TYPE：本页面存储什么类型的undo日志<br>前面的几种undo日志可以被分为两个大类</p></li><li><ul><li>TRX_UNDO_INSERT（使用十进制1表示）：类型为TRX_UNDO_INSERT_REC的undo日志属于这个大类</li><li>TRX_UNDO_UPDATE（使用十进制2表示）</li></ul></li><li><p>TRX_UNDO_PAGE_START：表示当前页面中什么位置开始存储undo日志</p></li><li><p>TRX_UNDO_PAGE_FREE：表示当前页面中存储的最后一条undo日志结束时候的偏移量</p></li><li><p>TRX_UNDO_PAGE_NODE：代表一个链表页面结构</p></li></ul><h2 id="20-6-Undo页面链表"><a href="#20-6-Undo页面链表" class="headerlink" title="20.6 Undo页面链表"></a>20.6 Undo页面链表</h2><p>因为一个事务可能会对若干条记录进行改动，所以在一个事务执行过程中可能产生很多undo日志。日志如果一个页面中放不下，需要放到多个页面中，这些页面通过TRX_UNDO_PAGE_NODE属性连成了链表。</p><p>因为一个页面只保存一种类型的UNDO日志，所以在一个事务的执行过程中需要2个Undo页面的链表：一个称为insert undo链表；另一个称为update undo链表。</p><p>另外，InnoDB规定，对普通表和临时表记录进行改动的时候产生的undo日志要进行分别记录。所以一个事务中最多有4个以Undo页面为节点组成的链表，具体分配策略：按需分配，需要和涉及到之后才分配。</p><p>同时，为了提高undo日志的写入效率，不同事务执行过程中产生的undo日志分别需要写入不同的undo页面链表中去。</p><h2 id="20-7-undo日志具体写入过程"><a href="#20-7-undo日志具体写入过程" class="headerlink" title="20.7 undo日志具体写入过程"></a>20.7 undo日志具体写入过程</h2><h3 id="20-7-1-段的概念"><a href="#20-7-1-段的概念" class="headerlink" title="20.7.1 段的概念"></a>20.7.1 段的概念</h3><p>段是一个逻辑上的概念，本质上是由若干个零散页面和若干个完整的区组成的。</p><h3 id="20-7-1-Undo-Log-Segment-Header"><a href="#20-7-1-Undo-Log-Segment-Header" class="headerlink" title="20.7.1 Undo Log Segment Header"></a>20.7.1 Undo Log Segment Header</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redo日志 - 《MySQL怎运》CH19</title>
      <link href="/2022/12/18/2022-12-18%20redo%E6%97%A5%E5%BF%97%20-%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCH19/"/>
      <url>/2022/12/18/2022-12-18%20redo%E6%97%A5%E5%BF%97%20-%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCH19/</url>
      
        <content type="html"><![CDATA[<h1 id="redo日志-《MySQL怎运》CH19"><a href="#redo日志-《MySQL怎运》CH19" class="headerlink" title="redo日志 - 《MySQL怎运》CH19"></a>redo日志 - 《MySQL怎运》CH19</h1><h2 id="19-2-redo日志是啥"><a href="#19-2-redo日志是啥" class="headerlink" title="19.2 redo日志是啥"></a>19.2 redo日志是啥</h2><p>InnoDB是以页为单位来管理存储空间的，之前进行增删改查的过程都是在访问页面。</p><p>在谈到buffer Pool的时候，真正访问页面都是将磁盘中的的页加载到内存中的Buffer Pool中去。</p><p>但是事务又是持久化的，对于一个已经提交的事务，事务对于数据库中的更改不能丢失，所以如果事务修改在buffer pool中的，数据库中发生了某些故障，可能导致数据丢失，这种情况是不能容忍的。</p><p>一个简单粗暴的做法就是在事务提交完成之后，将该事务修改的所有页面都刷新到磁盘，不过这个方法存在下面这些问题：</p><ul><li>刷新一个完整的数据页太浪费了。有时候仅仅修改了每个页面中的一个字节，但是提交必须将一整个完整页面从内存刷新到磁盘。</li><li>随机刷新起来比较慢。一个事务可能包含很多语句，有时候一条语句也可能修改许多页面，意为着在某个事务修改的Buffer Pool中的页面核算新到磁盘的时候，需要进行很多的随机I&#x2F;O</li></ul><p>其实，没有必要在每次提交事务时就把该事务在内存中修改的页面全部刷新到磁盘，只要记录修改的内容就可以了。比如，某一处修改只要如下记录</p><p>将第0号表空间第100号页面中偏移量为1000处的值更新为2</p><p>这样事务提交时候，将记录步骤重新执行一遍，就可以将事务对于数据库做的修改回复出来。</p><p>因为在系统重启时按照记录的步骤重新更新数据页，所以提交的内容也被称为重做日志（redo log）。相较于在事务提交时将修改过的内存中的页面刷新到磁盘中，只将该事务执行过程中产生的redo日志刷新到磁盘具有下面这些优点：</p><ul><li>redo日志占用的空间非常小：在存储空间ID、页号、偏移量以及需要更新的值时，需要的存储空间很小。</li><li>redo日志是顺序写入磁盘的：在执行事务的时候，每执行一条语句，产生若干条redo日志，这些日志按照产生顺序写入磁盘的，使用顺序I&#x2F;O。</li></ul><h2 id="19-3-redo日志格式"><a href="#19-3-redo日志格式" class="headerlink" title="19.3 redo日志格式"></a>19.3 redo日志格式</h2><p>绝大部分redo日志都有下面这种通用结构：</p><p><img src="/xkond/2022/12/18/2022-12-18%20redo%E6%97%A5%E5%BF%97%20-%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCH19/1671337539541-9f0ba872-4407-4183-b0b9-863dcc0c2a2b.png" alt="img"></p><p>各个部分详细解释：</p><ul><li>type：这条redo日志的类型<br>在MySQL 5.7.22 版本中，一共设计了53中不同类型的redo日志</li><li>space ID：表空间ID</li><li>page number：页号</li><li>data：redo日志的具体内容</li></ul><h3 id="19-3-1-简单的redo日志类型"><a href="#19-3-1-简单的redo日志类型" class="headerlink" title="19.3.1 简单的redo日志类型"></a>19.3.1 简单的redo日志类型</h3><p>如果没有为某个表显示地定义组件，并且表中也没有定义不允许存储NULL的UNIQUE键，那么InnoDB会自动为表添加一个名为row_id的隐藏列作为主键，这个row_id隐藏列的复制方式如下</p><ul><li>服务器在内存中维护一个全局变量，每当某个包含row_id隐藏列的表中插入一条记录时，将全局变量的值作为row_id，并且把这个全局变量自增1</li><li>每当全局变量为256的倍数时，将该变量的值刷新到系统表空间页号为7的页面一个名为Max Row ID的属性（避免频繁刷盘）</li><li>当系统启动时，将这个MaxRowID属性加载到内存，并将该值加上256之后赋值给全局变量</li></ul><p>当某个事务向包含row_id隐藏列的表插入一条记录，并且为该记录分配的row_id值为256的倍数时，就会向系统表空间页号为7的页面的相应偏移量写入8字节的值。这个写入操作实际上是在Buffer Pool中完成的，我们需要把这次对这个页面的修改以redo日志的形式记录下来。</p><p>这种修改比较简单，redo日志只需要记录一下在某个页面的某个偏移量处修改了几个字节的值、具体修改的内容是啥。这种redo日志称为物理日志，并且根据在页面中写入数据的多少划分了几种不同的redo日志类型。</p><ul><li>MLOG_1BYTE(type字段对应的十进制数字为1)：表示在页面的某个偏移量处写入1字节的redo日志类型</li><li>MLOG_2BYTE：略</li><li>MLOG_4BYTE：略</li><li>MLOG_8BYTE：略</li><li>MLOG_WRITE_STRING(type字段对应的十进制数字为30)：表示在页面的某个偏移量处写入一个字节序列</li></ul><h3 id="19-3-2-复杂一些的redo日志类型"><a href="#19-3-2-复杂一些的redo日志类型" class="headerlink" title="19.3.2 复杂一些的redo日志类型"></a>19.3.2 复杂一些的redo日志类型</h3><p>略</p><h2 id="19-4-Mini-Transaction"><a href="#19-4-Mini-Transaction" class="headerlink" title="19.4 Mini-Transaction"></a>19.4 Mini-Transaction</h2><h3 id="19-4-1-以组的形式写入redo日志"><a href="#19-4-1-以组的形式写入redo日志" class="headerlink" title="19.4.1 以组的形式写入redo日志"></a>19.4.1 以组的形式写入redo日志</h3><p>语句在执行过程中可能修改若干个页面，，由于这些页面更改都发生在Buffer Pool中，所以在修改完页面之后，需要记录相应的redo日志。在执行语句过程中产生的redo日志，被认为划分为若干个不可分割的组，比如：</p><ul><li>更新Max Row ID属性时产生的redo日志为一组，是不可分割的；</li><li>向聚簇索引对应B+树的页面中插入一条记录时产生的redo日志是一组，是不可分割的；</li><li>向某个二级索引对应B+树的页面中插入一条记录时产生的redo日志是一组，是不可分割的；</li><li>还有一些不可分割的组</li></ul><p>这些不可分割，以向某个索引对应B+树中插入一条记录为例；在向B+树插入这条记录之前，需要先定位这条记录被插入到哪一个叶子节点为代表的数据页中。定位到具体的数据页之后，有两种可能的情况：</p><ul><li>情况1：该数据页剩余空闲空间相当充足，足够容纳这条插入数据。<br>之后，直接将记录插入数据页，然后记录一条MLOG_COMP_REC_INSERT类型的redor日志。这种情况称为乐观插入<br>![img](2022-12-18 redo日志 - 《MySQL怎运》CH19&#x2F;1671358894861-a416a65f-00ac-4983-b251-665ef85b715d.png)![img](2022-12-18 redo日志 - 《MySQL怎运》CH19&#x2F;1671358917107-ac49195f-16d3-48cb-81e1-ce429501dd82.png)</li><li>情况2：该数据页剩余空闲空间不足。<br>遇到这种情况下，进行页分裂操作，就是新建一个叶子节点，把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，最后还要在内节点中添加一条目录项记录来指向这个新创建的页面。这种情况称为悲观插入</li></ul><p>![img](2022-12-18 redo日志 - 《MySQL怎运》CH19&#x2F;1671358945313-c2a3d1bd-fa80-47e2-a9c0-a76b23d9999a.png)</p><p>![img](2022-12-18 redo日志 - 《MySQL怎运》CH19&#x2F;1671358975413-c08eef95-873c-4a36-a988-3499f8cfaf63.png)</p><p>甚至可能存在作为内节点的页a剩余空间不足以容纳新增的一条目录项就，则需要继续对内节点页a进行分裂操作，意味着会修改更多的页面，产生更多的redo日志。</p><p>设计MySQL时候认为，向某个索引对应B+树插入一条记录的过程必须是原子的，不能说插了一半之后就停止了。比如悲观插入过程中，每一个过程都是不能缺少的，如果缺少了，就会形成一个不正确的B+树。如果在悲观插入的过程中只记录了一部分的redo日志，那么在系统重启时会将索引对应的B+树恢复到一个不正确的状态。这种情况是不能被允许的，所以MySQL规定执行这些保证原子性的操作时，必须以组的形式来记录redo日志，恢复的时候，针对某个组中的redo日志，要么把全部的日志恢复，要么一条也不恢复。这就是之前提到的不可分割的一系列操作。</p><p>具体实现上：</p><ul><li>有些保证原子性的操作会生成多条redo日志</li></ul><p>把这些redo日志划分到一个组里面，MySQL使用了一个小把戏。在该组最后一个redo日志后面加上一条特殊的redo日志。该类型的redo日志名称为<strong>MLOG_MULTI_REC_END</strong>，结构很简单，只有一个type字段。<br>所以在某个需要保证原子性的操作锁产生的一系列redo日志，必须以一条<strong>MLOG_MULTI_REC_END</strong>的redo日志结尾。之后在系统因崩溃而重启恢复时，只有解析到类型为<strong>MLOG_MULTI_REC_END</strong>的redo日志，才认为解析到了一组完整的redo日志</p><ul><li>有些需要保证原子性的操作值生成一条redo日志，比如更新max row id属性的操作</li></ul><p>如果type字段的第一个比特为1，代表这个需要保证原子性的操作值产生了一条单一的redo日志；否则就认为这个需要保证原子性的操作产生了一系列的redo日志</p><h3 id="19-4-2-Mini-Transaction的概念"><a href="#19-4-2-Mini-Transaction的概念" class="headerlink" title="19.4.2 Mini-Transaction的概念"></a>19.4.2 Mini-Transaction的概念</h3><p>设计MySQL将对底层页面进行一次原子性访问称为一个Mini-Transaction（MTR）</p><p>一个事务可以包含若干条语句，每一个语句又可以包含若干个MTR，每一个MTR又可以包含若干条redo日志。</p><p>![img](2022-12-18 redo日志 - 《MySQL怎运》CH19&#x2F;1671359975473-e1b1ff72-4b0a-47c2-b35e-069ca9e6bc75.png)</p><h2 id="19-5-redo日志的写入过程"><a href="#19-5-redo日志的写入过程" class="headerlink" title="19.5 redo日志的写入过程"></a>19.5 redo日志的写入过程</h2><h3 id="19-5-1-redo-log-block"><a href="#19-5-1-redo-log-block" class="headerlink" title="19.5.1 redo log block"></a>19.5.1 redo log block</h3><p>MySQL将通过MTR生成的redo日志都放在了大小为512字节的页中，称为redo log block</p><h3 id="19-5-2-redo日志缓冲区"><a href="#19-5-2-redo日志缓冲区" class="headerlink" title="19.5.2 redo日志缓冲区"></a>19.5.2 redo日志缓冲区</h3><p>为了解决磁盘速度过慢的问题引入了Buffer Pool。同理，redo日志也不能直接写到磁盘中，服务器中有申请的一块连续内存空间称为redo log buffer ，这篇内存空间被划分为若干个连续的redo log block。</p><p>可以通过启动选项innodb_log_buffer_size指定log buffer 的大小，默认值为16MB。</p><h3 id="19-5-3-redo日志写入log-buffer"><a href="#19-5-3-redo日志写入log-buffer" class="headerlink" title="19.5.3 redo日志写入log buffer"></a>19.5.3 redo日志写入log buffer</h3><p>向log buffer中写入redo日志的过程是顺序写入的，也就是先往前面的block中写，当该block用完之后网下一个block中写</p><p>![img](2022-12-18 redo日志 - 《MySQL怎运》CH19&#x2F;1671360331111-b4fa84c0-7cad-4c35-943c-1905800f7176.png)</p><p>因为一个MTR执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以并不是每生成一条redo日志就插入到log buffer中，而是将每个MTR运行过程中产生的日志先暂存到一个地方；当MTR结束的时候，再将过程中产生的一组redo日志全部赋值到log buffer中。</p><p>不同的事务可能是并发执行的，所以每当一个MTR执行完成时，伴随该MTR生成的一组redo日志就需要被复制到log buffer中。</p><p>![img](2022-12-18 redo日志 - 《MySQL怎运》CH19&#x2F;1671360765623-2cbbea25-fb28-4654-bf97-1cc7b7b0eb06.png)</p><h2 id="19-6-redo日志文件"><a href="#19-6-redo日志文件" class="headerlink" title="19.6 redo日志文件"></a>19.6 redo日志文件</h2><h3 id="19-6-1-redo日志刷盘时机"><a href="#19-6-1-redo日志刷盘时机" class="headerlink" title="19.6.1 redo日志刷盘时机"></a>19.6.1 redo日志刷盘时机</h3><p>MTR运行过程中产生的一组redo日志会在MTR结束时被复制到log buffer中。在一些情况下会被刷新到磁盘中去。</p><ul><li>log buffer空间不足时候<br>MySQL设计时，如果当前写入log buffer的redo日志量已经占满了log buffer总容量的50%左右，就需要把这些日志刷新到磁盘中</li><li>事务提交时<br>引入redo日志的概念，主要是因为其占用空间少，而且可以将其顺序写入磁盘。<br>为了保证持久性，在事务提交时，必须要把页面修改时锁对应的redo日志刷新到磁盘；否则系统崩溃后，无法将该事务对页面的修改恢复过来。</li><li>当某个脏页刷新到磁盘前，会保证先将该脏页对应redo日志刷新到磁盘</li><li>后台一个线程，大约以每秒一次的频率刷新log buffer中的redo log日志刷新到磁盘</li><li>正常关闭服务器时</li><li>做checkpoint时</li></ul><h3 id="19-6-2-redo日志文件组"><a href="#19-6-2-redo日志文件组" class="headerlink" title="19.6.2 redo日志文件组"></a>19.6.2 redo日志文件组</h3><p>MySQL数据目录下more有名为ib_logfile0和ib_logfile1的两个文件，这些文件使用ib_logfile[数字]进行命名，这些就是日志文件组</p><h3 id="19-6-3-redo日志文件格式"><a href="#19-6-3-redo日志文件格式" class="headerlink" title="19.6.3 redo日志文件格式"></a>19.6.3 redo日志文件格式</h3><p>略</p><h2 id="19-7-log-sequence-number"><a href="#19-7-log-sequence-number" class="headerlink" title="19.7 log sequence number"></a>19.7 log sequence number</h2><p>自系统开始运行之后，就会不断的生成redo日志，redo日志的量在不断递增。InnoDB设计了一个名为lsn（log sequence number）的全局变量，用来记录当前总共写入的redo日志量，初识的lsn值为8704，每一组MTR生成的redo日志都有一个唯一的lsn值与其对应；lsn值越小，说明redo日志产生的越早</p><h3 id="19-7-1-flushed-to-disk-lsn"><a href="#19-7-1-flushed-to-disk-lsn" class="headerlink" title="19.7.1 flushed_to_disk_lsn"></a>19.7.1 flushed_to_disk_lsn</h3><p>InnoDB设计了一个表示刷新到磁盘的redo日志量的全局变量，名为flusher_to_dis_lsn，表示当前已经刷新到磁盘的redo日志对应的lsn值</p><hr><h1 id="个人收获"><a href="#个人收获" class="headerlink" title="个人收获"></a>个人收获</h1><p>MySQL设计中有一些通用的点，可以加以总结</p><p>性能方面，为了提高性能，采用了以下措施</p><ol><li>对数据的访问和修改，加入buffer层，减少IO操作</li><li>对于必须的IO操作，引入中间层，使用顺序IO代替随机IO</li><li>加上一层控制层，不直接操作对应的数据页，而是通过目录页定位访问数据页</li></ol><p>为了保证业务的正确性，采用了一些措施</p><ol><li>对于buffer何时刷新到磁盘，根据业务进行控制，通常有buffer不够，后台线程，必须更新几种情况</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务简介 - 《MySQL怎运》CH18</title>
      <link href="/2022/12/11/2022-12-11%20%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B%20-%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCH18/"/>
      <url>/2022/12/11/2022-12-11%20%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B%20-%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCH18/</url>
      
        <content type="html"><![CDATA[<h1 id="事务简介-《MySQL怎运》CH18"><a href="#事务简介-《MySQL怎运》CH18" class="headerlink" title="事务简介 - 《MySQL怎运》CH18"></a>事务简介 - 《MySQL怎运》CH18</h1><h2 id="18-1-事务的起源"><a href="#18-1-事务的起源" class="headerlink" title="18.1 事务的起源"></a>18.1 事务的起源</h2><p>如果在执行两条语句的时候，服务器出现故障，两条语句一条执行完成，但是另外一条没有执行，可能导致业务的不完整，只有一条语句被完整执行</p><p>例如从一个银行账户转账，如果只从转出的账户扣钱，但是没有对被转入的账户扣钱，这种情况是不能被接收的。</p><p>程序员的工作就是把现实世界的业务场景映射到数据库中，现实中状态转化的规则有以下几条</p><h3 id="18-1-1-原子性"><a href="#18-1-1-原子性" class="headerlink" title="18.1.1 原子性"></a>18.1.1 原子性</h3><p>在现实中，转账操作是一个不可分割的操作，要么没有转账，要么转账成功，不存在中间状态。</p><p>要么全做，要么全不做，这种规则称为原子性</p><p>但是对于数据库中的操作通常会被分解为若干个步骤，但是在任何一个时间点都可能发生意外，保证数据某些操作的原子性，需要采取一些手段保证</p><h3 id="18-1-2-隔离性"><a href="#18-1-2-隔离性" class="headerlink" title="18.1.2 隔离性"></a>18.1.2 隔离性</h3><p>现实中，两次状态转换应该是互不影响的。</p><p>但是数据库中某些操作因为执行顺序的问题，两次状态转换之间可能会存在相互影响的，所以需要一手手段保证其他的状态转换不会相互影响</p><h3 id="18-1-3-一致性"><a href="#18-1-3-一致性" class="headerlink" title="18.1.3 一致性"></a>18.1.3 一致性</h3><p>&#x2F;&#x2F; 略</p><h3 id="18-1-4-持久性"><a href="#18-1-4-持久性" class="headerlink" title="18.1.4 持久性"></a>18.1.4 持久性</h3><p>当现实世界中的一个状态转换完成后，这个转换的结果将永久保留，这个规则被称为持久性</p><p>将现实世界中的状态映射出来，持久性意味着该次转换对应的数据库操作锁修改的数据都应该在磁盘中永久保存下来</p><h2 id="18-2-事务的概念"><a href="#18-2-事务的概念" class="headerlink" title="18.2 事务的概念"></a>18.2 事务的概念</h2><p>MySQL将保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为事务（transaction）</p><p>根据操作执行的不同阶段将事务划分以下几个状态</p><ul><li>活动的：正在执行数据库操作的状态</li><li>部分提交：当最后一个操作执行完成，所有操作在内存中执行，还没有刷新到磁盘的状态</li><li>失败的：由于某些问题无法执行，或者人为停止了当前事务的执行的状态</li><li>中止的：事务执行了一半变为失败的状态，需要撤销失败的事务对当前的数据库的影响，当回滚执行完毕后，数据库恢复执行事务之前的状态</li><li>提交的：当一个部分提交的事务将修改过的数据都刷新到磁盘之后</li></ul><p><img src="/xkond/2022/12/11/2022-12-11%20%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B%20-%20%E3%80%8AMySQL%E6%80%8E%E8%BF%90%E3%80%8BCH18/1670166708692-6f27e3c7-c322-438e-811b-065d6e63401e.png" alt="img"></p><h2 id="18-3-MySQL中事务的语法"><a href="#18-3-MySQL中事务的语法" class="headerlink" title="18.3 MySQL中事务的语法"></a>18.3 MySQL中事务的语法</h2><h3 id="18-3-1-开启事务"><a href="#18-3-1-开启事务" class="headerlink" title="18.3.1 开启事务"></a>18.3.1 开启事务</h3><p>通过两种语句开启一个事务</p><ul><li><p>BEGIN [WORK];<br>后面的WORK可以缺少</p></li><li><p>START TRANSACTION;<br>开启一个事务，但是后面可以跟几个修饰符号</p></li><li><ul><li>READ ONLY：表示当前事务是一个只读事务，也就是该事务的数据库操作只能读取数据</li><li>READ WRITE：表示当前事务是一个读写事务，可以读也可以修改</li><li>WITH CONSISTENT SNAPSHOT：启动一致读写</li></ul></li></ul><p>不显示指定事务，该事务的访问模式就是读写模式</p><h3 id="18-3-2-提交事务"><a href="#18-3-2-提交事务" class="headerlink" title="18.3.2 提交事务"></a>18.3.2 提交事务</h3><p>COMMIT [WORK];</p><h3 id="18-3-2-手动终止事务"><a href="#18-3-2-手动终止事务" class="headerlink" title="18.3.2 手动终止事务"></a>18.3.2 手动终止事务</h3><p>ROLLBACK;</p><h3 id="18-3-4-支持事务的存储引擎"><a href="#18-3-4-支持事务的存储引擎" class="headerlink" title="18.3.4 支持事务的存储引擎"></a>18.3.4 支持事务的存储引擎</h3><p>在MySQL中，只有InnoDB和NDB存储引擎支持事务</p><h3 id="18-3-5-自动提交"><a href="#18-3-5-自动提交" class="headerlink" title="18.3.5 自动提交"></a>18.3.5 自动提交</h3><p>MySQL中有一个系统变量autocommit，用于提交事务</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW <span class="keyword">VARIABLES</span> LIKE <span class="comment">&#x27;autocommit&#x27;</span></span><br></pre></td></tr></table></figure><p>默认是ON，不过不显示使用开始事务语句，每一条语句就算是一个独立事务</p><p>想要关闭自动提交有两种方法：</p><ul><li>显示使用START TRANSACTION 或者BEGIN开启一个事务</li><li>将autocommit值设置为OFF</li></ul><h3 id="18-3-6-隐式提交"><a href="#18-3-6-隐式提交" class="headerlink" title="18.3.6 隐式提交"></a>18.3.6 隐式提交</h3><p>有些语句会导致自动提交（就像输入COMMIT语句一样）</p><ul><li>定义或修改数据库对象的数据定义语言（CRAETE、ALTRE、DROP)</li><li>隐式使用或修改MYSQL数据库中的表</li><li>事务控制或关于锁定的语句（在提交之前又开启一次事务）</li><li>加载数据的语句（LOAD DATA）</li><li>使用MySQL复制的语句</li><li>其他</li></ul><h3 id="18-3-7-保存点"><a href="#18-3-7-保存点" class="headerlink" title="18.3.7 保存点"></a>18.3.7 保存点</h3><p>MySQL存在保存点的概念，可以在ROLLBACK语句时候指定回滚到某一个点</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SAVEPOINT</span> 保存点名称</span><br></pre></td></tr></table></figure><p>回滚到某个保存点，可以使用下面这个语句</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> [<span class="keyword">WORK</span>] <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure><p>删除某个保存点可以使用：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> SAVE <span class="type">POINT</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>optimizer trace的神奇功效 -《MySQL是怎样运行的》ch16</title>
      <link href="/2022/11/27/2022-11-27%20optimizer-trace%E7%9A%84%E7%A5%9E%E5%A5%87%E5%8A%9F%E6%95%88/"/>
      <url>/2022/11/27/2022-11-27%20optimizer-trace%E7%9A%84%E7%A5%9E%E5%A5%87%E5%8A%9F%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch-16-optimizer-trace的神奇功效"><a href="#Ch-16-optimizer-trace的神奇功效" class="headerlink" title="Ch 16 optimizer trace的神奇功效"></a>Ch 16 optimizer trace的神奇功效</h1><h2 id="16-1-optimizer-trace简介"><a href="#16-1-optimizer-trace简介" class="headerlink" title="16.1 optimizer trace简介"></a>16.1 optimizer trace简介</h2><p>对于MySQL 5.6以及之前的版本来说，查询优化器像是一个黑盒子，无法知道它为什么做出这样的决定</p><p>在MySQL 5.6 以及之后的版本，可以通过开启optimizer trace，让用户查看优化器生成执行计划的整个过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;optimizer_trace&#x27;</span>;</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| Variable_name   | Value                    |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| optimizer_trace | enabled=off,one_line=off |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure><p>打开optimizer trace功能，需要把enabled的值修改为on</p><p><code>SET optimizer_trace=&quot;enabled=on&quot;</code></p><p>这之后可以输入想要查看优化过程的查询语句，当语句执行完成之后，可以在information_schema数据库下的OPTIMIZER_TRACE表中查看完整的执行计划生成过程（也可以使用EXPLAIN）</p><p><code>SELECT * FROM information_schema.OPTIMIZER_TRACE;</code></p><p>OPTIMIZER_TRACE表有4列，分别如下：</p><ul><li>QUERY：表示我们的查询语句</li><li>TRACE：表示优化过程的JSON格式的文本</li><li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE：执行计划生成过程中可能会输出很多内容，如果超过某个限制，多余文本不显示，这个字段展示了被忽略的文本字节数</li><li>INSUFFICIENT_PRIVILEGES：表示是否有权限查看执行计划的生成过程，默认值是0，表示有权限查看执行计划的生成过程</li></ul><p>当停止查看语句的优化过程时，关闭optimizer trace功能</p><p><code>SET optimizer_trace=&quot;enabled=on&quot;</code></p><h2 id="16-2-通过optimizer-trace分析查询优化器的具体工作过程"><a href="#16-2-通过optimizer-trace分析查询优化器的具体工作过程" class="headerlink" title="16.2 通过optimizer trace分析查询优化器的具体工作过程"></a>16.2 通过optimizer trace分析查询优化器的具体工作过程</h2><p><code>SELECT * FROM information_schema.OPTIMIZER_TRACE;</code></p><p>这个的输出大致分为3个阶段：</p><ul><li>prepare阶段</li><li>optimize阶段</li><li>execute阶段</li></ul><p>成本优化主要集中于optimize阶段，对于单表查询来说，主要关注optimize阶段的rows_estimation过程</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXPLAIN详解——查询优化的百科全书 -《MySQL是怎样运行的》ch15</title>
      <link href="/2022/11/13/2022-11-13%20EXPLAIN%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6/"/>
      <url>/2022/11/13/2022-11-13%20EXPLAIN%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch-15-查询优化的百科全书——EXPLAIN详解"><a href="#Ch-15-查询优化的百科全书——EXPLAIN详解" class="headerlink" title="Ch 15 查询优化的百科全书——EXPLAIN详解"></a>Ch 15 查询优化的百科全书——EXPLAIN详解</h1><p>MySQL查询优化器会基于成本和规则对于一条查询语句进行优化后，生成一个执行计划。</p><p>EXPLAIN语句，可以让我们查看某个查询语句的具体执行计划</p><p>可以在想查看的某个执行计划钱加上一个EXPLAIN，就可以输出执行计划</p><p>EXPLAIN语句的执行结果中各个列的作用大致如下</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中，每个SELECT关键字对应的唯一id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的查询类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际使用的索引</td></tr><tr><td>key_len</td><td>实际使用的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>针对预估的需要读取的记录，经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h2 id="15-1-执行计划输出中的各列详解"><a href="#15-1-执行计划输出中的各列详解" class="headerlink" title="15.1 执行计划输出中的各列详解"></a>15.1 执行计划输出中的各列详解</h2><h3 id="15-1-1-table"><a href="#15-1-1-table" class="headerlink" title="15.1.1 table"></a>15.1.1 table</h3><p>无论多么复杂的查询语句，里面包含多少表格，最后也是对每个表进行单表访问的，所以每个EXPLAIN输出记录都对应着某个单表的访问方法。如果涉及多个表</p><h3 id="15-1-2-id"><a href="#15-1-2-id" class="headerlink" title="15.1.2 id"></a>15.1.2 id</h3><p>查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值。</p><p>如果查询优化器对涉及子查询的查询语句进行了重写，转换为连接，则id值不会和SELECT数量一致</p><p>UNION表对于查询结果集合进行去重使用的是内部临时表，id值为NULL</p><h3 id="15-1-3-select-type"><a href="#15-1-3-select-type" class="headerlink" title="15.1.3 select_type"></a>15.1.3 select_type</h3><p>每个SELECT都有一个select_type的属性，代表这个小查询在整个大查询中扮演的角色，具体的类型结束如下</p><ul><li><p>SIMPLE</p><p>查询语句中不包含UNION或者子查询的查询就算做SIMPLE类型</p></li><li><p>PRIMARY</p><p>对于包含UNION、UNION ALL或者子查询的大查询来说，最左边的查询select_type就是PRIMARY</p></li><li><p>UNION</p><p>对于包含UNION或者UNION ALL的大查询来首，是由几个小查询组成的，除了最左边的小查询以外就是UNION</p></li><li><p>UNION ALL</p><p>用于UNION去重工作的临时表的select_type</p></li><li><p>SUBQUERY</p><p>如果包含子查询的查询语句不能转为对应的半连接形式，且该子查询是不相关子查询，并且查询优化器决定采用该子查询物化的方法执行子查询，是，子查询的第一个SELECT关键字代表的查询的select_type就是SUBQUERY</p></li><li><p>DEPENDENT SUBQUERY</p><p>如果包含子查询的查询语句不能装换为对应的半连接形式，并且子查询被查询优化器转换为相关子查询的形式，子查询的第一个SELECT关键字代表的查询的select_type就是DEPENDENT SUBQUERY</p></li><li><p>DEPENDENT UNION</p><p>在包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询，出最左边的小查询之外，其余的小查询的select_type的值就是DEPENDENT UNION</p></li><li><p>DERIVED</p><p>在包含派生表的查询中，如果是以物化派生表的方式执行查询，则派生表对应的子查询的select_type就是DERIVED</p></li><li><p>MATERIALIZED</p><p>当查询优化器在执行包含子查询的语句，选择将子查询物化之后与外层进行连接查询</p></li><li><p>其他（不常用，略）</p></li></ul><h3 id="15-1-4-partitions"><a href="#15-1-4-partitions" class="headerlink" title="15.1.4 partitions"></a>15.1.4 partitions</h3><p>分区相关，此处略</p><h3 id="15-1-5-type"><a href="#15-1-5-type" class="headerlink" title="15.1.5 type"></a>15.1.5 type</h3><p>执行查询的访问方法，一般来说访问性能依次变差（不是绝对，还取决于记录数量）</p><ul><li><p>system</p><p>表中只有一条记录且该表使用的存储引擎的统计数据时精确的（MyISAM、MEMORY）</p></li><li><p>const</p><p>根据主键或者一二级索引列与常数进行等值匹配</p></li><li><p>eq_ref</p><p>执行连接查询时，如果被驱动表时通过主键或者非NULL的唯一二级索引等值匹配进行访问的</p></li><li><p>ref</p><p>通过普通的二级索引列与常量进行等值匹配的方式来查询某个表</p></li><li><p>fulltext</p><p>全文索引</p></li><li><p>ref_or_null</p><p>当普通二级索引列进行等值匹配且该索引列的值也可以是NULL值时</p></li><li><p>index_merge</p><p>Intersection、Union、Sort-Union三种索引合并的方式执行查询</p></li><li><p>unique_subquery</p><p>查询优化器将子查询转换成EXISTS子查询，子查询转换之后使用主键或者非NULL二级索引等值匹配，子查询的访问访问方法</p></li><li><p>index_subquery</p><p>同上，但是子查询使用普通索引</p></li><li><p>range</p><p>使用索引获取单点扫描区间的记录</p></li><li><p>index</p><p>当可以使用索引覆盖，但需要扫描全部的索引记录时，访问方法是index</p></li><li><p>ALL</p><p>全表扫描</p></li></ul><h3 id="15-1-6-possible-keys和key"><a href="#15-1-6-possible-keys和key" class="headerlink" title="15.1.6 possible_keys和key"></a>15.1.6 possible_keys和key</h3><p>possible_keys列表示在某个查询语句中，执行可能用到的索引</p><p>key列表示实际用到的索引</p><p>possible_keys列中的值不是越多越好，可以使用的索引越多，查询优化器在计算查询成本时花费的事件就越长</p><h3 id="15-1-7-key-len"><a href="#15-1-7-key-len" class="headerlink" title="15.1.7 key_len"></a>15.1.7 key_len</h3><p>实际使用到的索引的长度</p><p>计算方式</p><ul><li>该列的实际数据最多占用的存储空间长度</li><li>如果该列可以存储NULL，在上面加1字节</li><li>对于编程烈性的列，在上面基础加2字节</li></ul><h3 id="15-1-8-ref"><a href="#15-1-8-ref" class="headerlink" title="15.1.8 ref"></a>15.1.8 ref</h3><p>当访问方法是const、eq_ref、ref、ref_of_null、unique_subquery、index_subquery中的其中一个时，ref列展示的就是与索引列进行等值匹配的东西是啥</p><h3 id="15-1-9-rows"><a href="#15-1-9-rows" class="headerlink" title="15.1.9 rows"></a>15.1.9 rows</h3><p>在查询优化器决定使用全表扫描执行查询时，执行计划的rows代表表的估计行数</p><p>如果使用索引执行查询时，执行计划的rows列代表预计扫描的索引记录行数</p><h3 id="15-1-10-filtered"><a href="#15-1-10-filtered" class="headerlink" title="15.1.10 filtered"></a>15.1.10 filtered</h3><p>filtered在查询计划执行过滤之后的百分比，计算驱动表扇出时采用的策略</p><ul><li>如果使用全表扫描的方式执行查询，计算驱动表扇出时需要估计满足全部搜索条件的记录有多少</li><li>如果使用索引执行单表查询，计算驱动表扇出时需要估计在满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条</li></ul><h3 id="15-1-11-Extra"><a href="#15-1-11-Extra" class="headerlink" title="15.1.11 Extra"></a>15.1.11 Extra</h3><p>Extra列用于说明一些额外信息，常见的重要额外信息如下</p><ul><li><p>No tables used：查询语句中没有FROM语句</p></li><li><p>Impossible WHERE：查询语句的WHERE永远为FALSE</p></li><li><p>No Matching min&#x2F;max row：查询列表有MIN或者MAX聚集函数，但是也有符合WHERE记录的搜索条件</p></li><li><p>Using Index：使用覆盖索引执行查询，只需要使用索引，且不需要回表</p></li><li><p>Using index condition：出现了索引列，但却不能充当边界条件形成扫描区间</p><p>比如<code>SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key1 LIKE &#39;%a&#39;;</code></p><p> key1 &gt; ‘z’可以形成扫描区间，key1 LIKE ‘%a’不能</p><p>但是此处因为搜索条件只涉及key1列，所以在会先在索引中判断其他其他的条件是否满足之后，通过后再进行回表</p><ol><li>server层先调用存储引擎API定位到第一个满足key1 &gt; ‘z’的二级索引</li><li>在回表之前，判断所有关于idx_key1的条件是否成立，如果这些条件不成立，直接跳过该二级索引记录（修改）</li><li>如果条件成立回表判断其他搜索条件是否成立</li><li>成立发送给客户端，之后要下一条索引记录</li></ol><p><strong>这个过程被称为索引条件下推</strong></p><p>因为每个记录有一个next_record属性，根据属性可以快速定位到下一条二级索引记录；因为每次回表操作都需要将一个聚簇索引加载到内存中，所以这个回表前的修改省去好多回表操作的成本</p></li><li><p>Using where：当某个搜索条件需要在server层进行判断时，在Extra列会提示Using where</p><p>例如下面这个查询</p><p><code>SELECT * FROM s1 WHERE key1 = &#39;a&#39; AND common_field = &#39;a&#39;;</code></p><p>在执行的时候会使用到idx_key1一级索引。但是索引并不包含common_field列，需要存储引擎根据二级索引记录执行回表操作，并将完整的用户记录返回给server层后，在server层判断条件是否成立</p></li><li><p>Using join buffer（Block Nested Loop）：在连接查询的过程中，当被驱动表不能有效地利用索引加快访问速度时，MySQL会为其分配一块名为连接缓冲区的内存块来加快查询速度；也就是使用</p><p>例如</p><p><code>SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;</code></p><p>对于s2的访问不能有效利用索引，所以使用Join Buffer来减少访问次数</p><p>因为s1是驱动表，s2是被驱动表，所以在访问s2表时，相当于common_field等于常数查询，using Where</p></li><li><p>Using intersect()、Using union、Using sort_union，使用索引合并的方式进行查询</p></li><li><p>Zero Limit：当Limit子句的参数为0时</p></li><li><p>Using filesort：当排序操作无法使用到索引，需要在内存或者磁盘中进行排序的时候，这种排序方式统称为filesort，当文件较多时，这过程非常耗费性能</p></li><li><p>Using temporary：借助了内部的临时表进行查询（比如 DISTINCT、GROUP BY、UNION等子句）</p><blockquote><p>包含GROUP BY的子句默认条件ORDER BY子句，可以显示的加上 ORDER BY NULL取消</p></blockquote><p>因为建立与维护临时表需要付出很大的成本，最好使用索引或者其他方式替代</p></li><li><p>Start temporary，End temporary：将IN子查询转换成半连接，且执行策略是Duplicate Weedout时候，建立临时表为外层记录进行去重的时候，驱动表执行的Extra显示为Start temporary，被驱动表查询执行计划的Extra显示为End temporary</p></li><li><p>LooseScan：将IN子查询转为半连接的时候，如果采用LooseScan执行策略，则驱动表的执行计划Extra为LooseScan</p></li><li><p>FirstMatch（tbl_name)：同上，采取FirstMatch策略</p></li></ul><h2 id="15-2-JSON格式的执行计划"><a href="#15-2-JSON格式的执行计划" class="headerlink" title="15.2 JSON格式的执行计划"></a>15.2 JSON格式的执行计划</h2><p>在EXPLAIN中加上FORMAT&#x3D;JSON得到JSON格式的执行计划</p><p><code>EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field  = &#39;a&#39;;</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 优化 </tag>
            
            <tag> 查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于规则的优化（含子查询优化） -《MySQL是怎样运行的》ch14</title>
      <link href="/2022/10/25/2022-10-25%20%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E5%90%AB%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%EF%BC%89/"/>
      <url>/2022/10/25/2022-10-25%20%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E5%90%AB%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch-14-基于规则的优化（含子查询优化二三事）"><a href="#Ch-14-基于规则的优化（含子查询优化二三事）" class="headerlink" title="Ch 14 基于规则的优化（含子查询优化二三事）"></a>Ch 14 基于规则的优化（含子查询优化二三事）</h1><p>存在一些MySQL语句执行起来非常耗时，MySQL会根据一些规则将这些语句转换成为一些高效执行的形式</p><p>这一过程被称为<strong>查询重写</strong></p><h2 id="14-1-条件化简"><a href="#14-1-条件化简" class="headerlink" title="14.1 条件化简"></a>14.1 条件化简</h2><p>查询语句本质是表达式，MySQL优化器会简化这些表达式</p><h3 id="14-1-1-移除不必要的括号"><a href="#14-1-1-移除不必要的括号" class="headerlink" title="14.1.1 移除不必要的括号"></a>14.1.1 移除不必要的括号</h3><p>表达式中会存在无用的括号，优化器会移除掉这些不必要的括号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (t1, (t2, t3)) <span class="keyword">WHERE</span> t1.a <span class="operator">=</span> t2.a <span class="keyword">AND</span> t2.b <span class="operator">=</span> t3.b</span><br><span class="line"><span class="comment">-- 移除后</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2, t3 <span class="keyword">WHERE</span> t1.a <span class="operator">=</span> t2.a <span class="keyword">AND</span> t2.b <span class="operator">=</span> t3.b</span><br></pre></td></tr></table></figure><h3 id="14-1-2-常量传递"><a href="#14-1-2-常量传递" class="headerlink" title="14.1.2 常量传递"></a>14.1.2 常量传递</h3><p>如果比较的是常量，会将常量替换称为数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> a</span><br><span class="line"><span class="comment">-- 替换</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="14-1-3-移除没有的条件"><a href="#14-1-3-移除没有的条件" class="headerlink" title="14.1.3 移除没有的条件"></a>14.1.3 移除没有的条件</h3><p>一些明显为TRUE和FALSE的条件会被替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> b) <span class="keyword">OR</span> (a <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> <span class="number">5</span> <span class="operator">!=</span> <span class="number">5</span>)</span><br><span class="line"><span class="comment">-- 更新</span></span><br><span class="line">(a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="literal">TRUE</span>) <span class="keyword">OR</span> (a <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><h3 id="14-1-4-表达式计算"><a href="#14-1-4-表达式计算" class="headerlink" title="14.1.4 表达式计算"></a>14.1.4 表达式计算</h3><p>如果简单表达式结果是常量会被化简</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- 化简</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复杂表达式如下不会被化简</span></span><br><span class="line"><span class="built_in">ABS</span>(a) <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="operator">-</span>a <span class="operator">&lt;</span> <span class="number">-8</span> </span><br></pre></td></tr></table></figure><h3 id="14-1-5-HAVING子句和WHERE子句的合并"><a href="#14-1-5-HAVING子句和WHERE子句的合并" class="headerlink" title="14.1.5 HAVING子句和WHERE子句的合并"></a>14.1.5 HAVING子句和WHERE子句的合并</h3><p>如果没有没有SUM、MAX聚集函数和GROUP BY子句，优化器会把HAVING和WHERE子句合并起来</p><h3 id="14-1-6-常量表检查"><a href="#14-1-6-常量表检查" class="headerlink" title="14.1.6 常量表检查"></a>14.1.6 常量表检查</h3><p>有两种查询很快</p><ul><li>查询的表中不超过1条数据</li><li>使用主键等值匹配或者一二级索引列等值匹配搜索条件</li></ul><p>通过这两种方式查询的表称为常量表，一个查询语句会首先执行常量查询，然后将涉及的数据替换称为常数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table1 <span class="keyword">ON</span> table1.column1 <span class="operator">=</span> table2.column2 <span class="keyword">WHERE</span> table1.primary_key <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 会将涉及table1的表替换成为常数</span></span><br><span class="line"><span class="keyword">SELECT</span> table1常量, table2.<span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table1 <span class="keyword">ON</span> table1.column1常量 <span class="operator">=</span> table2.column2;</span><br></pre></td></tr></table></figure><h2 id="14-2-外连接消除"><a href="#14-2-外连接消除" class="headerlink" title="14.2 外连接消除"></a>14.2 外连接消除</h2><p>内连接可以交换驱动表和被驱动表，所以内连接可能通过优化表的连接顺序来降低整体的查询成本，外连接却无法优化表的连接顺序</p><p>对于外连接的驱动表记录，如果无法在被驱动表中找到ON语句过滤条件的记录，那么该驱动表记录仍然会加入结果集中，对应的被驱动表记录使用NULL字段填充；</p><p>而对于内连接的驱动表记录如果无法在驱动表中找打匹配ON子句中过滤条件，该驱动表记录会被舍弃</p><p>如果在WHERE子句中指定“被驱动表的列不为NULL”的搜索条件，那么在外连接中被驱动表找不到服务ON子句条件的驱动表也会从最后的结果集中排除</p><p>这种情况下，外连接和内连接就没有什么区别了</p><p>在这种外连接查询中，包含被驱动表中的列不为NULL值的条件称为空值拒绝（reject-NULL）；此种情况下外连接和内连接可以相互转换。这种转换带来的好处就是优化器可以评估不同连接顺序的成本，选出最低的连接顺序执行查询。</p><h2 id="14-3-子查询优化"><a href="#14-3-子查询优化" class="headerlink" title="14.3 子查询优化"></a>14.3 子查询优化</h2><h3 id="14-3-1-子查询语法是什么"><a href="#14-3-1-子查询语法是什么" class="headerlink" title="14.3.1 子查询语法是什么"></a>14.3.1 子查询语法是什么</h3><p>在查询语句中的某一个位置也有另外一个查询语句，这个查询被称为子查询，一个子查询可以出现在外层查询的任意位置。</p><ul><li><p>在SELECT子句中</p><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> m1 <span class="keyword">FROM</span> t1 LIMIT <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>在FROM子句中</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m, n <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> m2 <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> m. n2 <span class="keyword">AS</span> n <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> m2 <span class="operator">&gt;</span> <span class="number">2</span>) <span class="keyword">AS</span> t;</span><br></pre></td></tr></table></figure><p>这个在FROM子句中的子查询的结果当做一个新的查询的表；这种放在FROM子句后面的查询称为派生表</p></li><li><p>在WHERE或者ON子句的表达式中</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">in</span> (<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2)</span><br></pre></td></tr></table></figure><p>这个查询表示我们想要在找t1表中的某些记录，这些记录的在t2表中的m2列找到匹配的值</p></li><li><p>ORDER BY子句（略）</p></li><li><p>GROUP BY子句（略）</p></li></ul><p><strong>子查询的分类</strong>：</p><ol><li><p>按返回的结果集区分子查询</p><ul><li><p>标量子查询：只返回一个单一值的子查询被称为标量子查询</p><p>例如<code>SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2)</code></p></li><li><p>行子查询：返回一条记录的自查询，但是包含多个列</p><p>例如<code>SELECT * FROM t1 WHERE (m1, n1) = （SELECT m2, n2 FROM t2 LIMIT 1);</code> </p></li><li><p>列子查询：查询出一个列的数据，但是这个列包含多条数据</p><p>例如<code>SELECT * FROM t1 WHERE m1 in (SELECT m2 FROM t2);</code></p></li><li><p>表子查询：子查询的结果包含很多条记录和很多列</p><p>例如：<code>SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);</code></p></li></ul></li><li><p>按与外层查询的关系来区分子查询</p><ul><li><p>不相关子查询</p><p>如果子查询可以单独运行运行出结果，而不依赖外层查询的值，这个子查询被称为不相关子查询</p></li><li><p>相关子查询</p><p>如果子查询执行依赖于外层查询，称为相关子查询</p></li></ul></li></ol><p><strong>子查询在布尔表达式中的使用</strong></p><ul><li><p>使用比较操作符的表达式</p><p>例如：<code>SELECT * FROM t1 WHERE m1 &lt; (SELECT MIN(m2) FROM t2);</code></p></li><li><p>[NOT] IN&#x2F;ANY&#x2F;SOME&#x2F;ALL子查询</p><p>许多条记录的比较</p><ul><li><p>[NOT] IN</p><p>例如：<code>SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);</code></p></li><li><p>ANY&#x2F;SOME  </p><p>例如：<code>SELECT * FROM t1 WHERE m1 &gt; ANY(SELECT m2 FROM t2);</code></p><p>该表达式只要在子查询的结果集中存在一个值为TRUE，结果即为TRUE</p></li><li><p>ALL</p><p>例如：<code>SELECT * FROM t1 WHERE m1 &gt; ALL(SELECT m2 FROM t2);</code></p><p>该表达式需要查询集的结果中左右值都满足TRUE</p></li></ul></li><li><p>EXISTS子查询</p><p>仅仅判断子查询中是否存在记录</p><p>例如：<code>SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2);</code></p></li></ul><p><strong>子查询语法注意事项</strong></p><ul><li>子查询必须用小括号括起来</li><li>在SELECT子句中的子查询必须是标量子查询</li><li>如果想要得到标量子查询但是有不能保证结果集只有一条时，应该使用LIMIT 1语句限制数量</li><li>对于[NOT] IN&#x2F;ANY&#x2F;SOME&#x2F;ALL 子查询来说，子查询中不允许有LIMIT语句</li><li>不允许一条子句同时在语句中怎删改某个表的记录同时，对该表格进行子查询</li></ul><h3 id="14-3-2-子查询在MySQL中是怎么执行的"><a href="#14-3-2-子查询在MySQL中是怎么执行的" class="headerlink" title="14.3.2 子查询在MySQL中是怎么执行的"></a>14.3.2 子查询在MySQL中是怎么执行的</h3><h4 id="1-标量子查询、行子查询的执行方式"><a href="#1-标量子查询、行子查询的执行方式" class="headerlink" title="1. 标量子查询、行子查询的执行方式"></a>1. 标量子查询、行子查询的执行方式</h4><p>对于不相关的子查询，执行步骤如下：</p><ol><li>单独执行括号内的子查询</li><li>将子查询的结果作为外层查询的参数，执行外层查询</li></ol><p>对于相关的子查询，执行步骤：</p><ol><li>从外层获取一条记录</li><li>从记录中找到子查询涉及的值，然后执行子查询</li><li>根据子查询检测外层条件是否成立，如果不成立就丢弃</li><li>重复第一步，直到查询获取不到记录</li></ol><h4 id="2-IN子查询优化"><a href="#2-IN子查询优化" class="headerlink" title="2. IN子查询优化"></a>2. IN子查询优化</h4><ol><li><p>物化表的提出</p><p>对于不相关的IN子查询，比如：</p><p><code>SELECT * FROM s1 WHERE key in (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;);</code></p><p>如果对于子查询结果集中的记录条数很多的情形，可以把子查询和外层查询分别看成两个单独的单表查询，效率还是蛮高的</p><p>但是如果子查询中的结果集太多，可能内存中存不下来</p><p>对于这种情形，MySQL设计时采用将结果集写入一个临时表中。在写入临时表中有两个注意事项：</p><ul><li><p>临时表的列就是子查询结果集中的列</p></li><li><p>写入临时表的记录会被去重</p><blockquote><p>因为IN语句就是判断操作是否存在于某个集合中，集合中的重复值对于IN语句的结果没有啥关系</p></blockquote></li></ul><p>一般情况下，子查询的结果集不会大得离谱，所以会为它建立基于内存使用MEMORY存储引擎的临时表，而且会为该表建立哈希索引</p><p>如果子查询的结果集非常大，超管系统变量<code>tmp_table_size</code>或者<code>max_heap_table_size</code>的值，临时表就会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型转变为B+树索引</p><p>这个保存临时表的过程被称为物化；存储的临时表被称为物化表</p></li><li><p>物化表转连接</p><p>当子查询物化后，该查询从两个角度理解</p><ol><li>从表s1角度：该查询中，每个s1表中的记录，如果key1列在子查询的物化表中，该记录加入最终结果集</li><li>从物化表角度：每个物化表的每个值中，能在s1表中找到对应的key1列的值与该值相等的记录，这些记录加入最终结果集</li></ol><p>也就是说，原查询可以相当于表s1与子查询物化表materialized_table进行内连接</p><p><code>SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val(物化表的列);</code></p><p>转换成连接之后，查询优化器可以评估不同连接顺序的成本，然后选择成本最低的方式执行查询。</p><p>如果使用s1表作为驱动表，总查询成本由下面几个部分组成</p><ul><li>物化子查询的成本</li><li>扫描s1表的成本</li><li>s1表中的记录 * 通过条件m_val &#x3D; xxx对于materialized_table的表进行单表访问的成本(因为去重，索引性能非常高)</li></ul><p>如果使用materialized_table作为驱动表，总查询成本由几个部分组成：</p><ul><li>物化子查询时需要的成本</li><li>扫描物化表时的成本</li><li>物化表的记录数量 * 通过条件key1 &#x3D; xxx对于s1表进行单表访问的成本</li></ul></li><li><p>将子查询转换为半连接</p><p>因为将子查询进行物化之后再执行查询会有建立临时表的成本，那么能不能不进行物化操作，直接把子查询转换为连接呢。</p><p>对于上面的查询语句</p><p><code>SELECT * FROM s1 WHERE key in (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;);</code></p><p>可以将这个查询理解成：对于s1表中的某条记录，如果能在s2表中找到一条或多条记录，这些记录的common_field值等于s1表记录的key1列的值，那么该条s1表的记录就会别加入到最终的结果集，这个查询类似于连接s1和s2表</p><p><code>SELECT s1.* FROM s1 INNER JOIN s2 ON s1.key1 = s2.common_field WHERE s2.key3 = &#39;1&#39;</code></p><p>只不过我们不能保证对于s1表的某条记录来说，在s2表中有多少条记录满足s1.key &#x3D; s2.common_field条件，不过可以分3种情况讨论</p><ul><li>情况1：对于s1表中的某条记录来说，s2表中没有一条满足条件，该记录不加入结果集</li><li>情况2：对于s1表中的某条记录来说，s2表中有且只有一条记录满足条件，该记录加入结果集</li><li>情况3：对于s1表中的某条记录来说，s2表中至少有两条记录满足条件，该记录会多次加入最终的结果集</li></ul><p>因为情况3的存在，所以子查询和两表连接不完全等价，但是子查询转换为连接确实可以充分发挥优化器作用，因此引入一个性概念——半连接。</p><p>将s1表和s2表进行半连接的意思就是：对于s1表中的某条记录来说，我们只关心在s2表中是否存在，而不关心具体存在多少条记录与之匹配，最终的结果集只保留s1表的巨鹿</p><blockquote><p>并不存在面向用户的半连接语法</p></blockquote><p><strong>如何实现半连接</strong></p><ul><li><p>Table pullout（子查询中的表上拉）</p><p>子查询列表处只有主键或者唯一索引列是，可以把子查询的表上拉到外层查询的FROM子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中。直接转换成为内连接，因为查询的条件保证了数据的不重复性质</p></li><li><p>Duplicate Weedout（重复值消除）</p><p>转换为半连接查询后，在执行连接查询的过程中，创建一个临时表，每当某条s1表中的记录要加入结果集的时候，将这条记录插入临时表，如果添加成功，说明这条s1表中的记录并没有加入结果集，该记录直接加入最终结果集，反之丢弃</p></li><li><p>LooseScan（松散扫描）</p><p>对于下面这个查询</p><p><code>SELECT * FROM s1 WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; &#39;a&#39; AND key1 &lt; &#39;b&#39;</code></p><p>在子查询s2表中可以用到key1列的索引，而子查询的查询列表恰好是key1列，这样将s2作为驱动表执行查询，对于相同值，每次只去第一个值到表s1中查找满足条件的记录，如果能在s1表中查到对应记录，则加入结果集</p></li><li><p>Semi-join Materialization(半连接物化)</p><p>之前提到的创建物化表然后进行连接</p></li><li><p>FirstMatch（首次匹配）</p><p>先取一条外层查询中的记录然后到子查询的表中寻找符合条件的记录。然后到子查询的表中寻找符合匹配条件的记录，找到则放入结果集，找不到则丢弃。过程不断重复，直到外层查询获取不到记录为止</p></li></ul><p><strong>半连接的适用条件</strong></p><p>并不是所有包含IN的子查询都可以转换为半连接，只有符合一定条件的子查询才可以</p><ul><li>该子查询必须是与IN操作符组成的布尔表达式，并且在外层查询的WHERE或者ON子句中出现</li><li>外层查询也可以有其他的搜索条件，只不过必须使用AND操作符和与IN子查询的搜索条件连接起来</li><li>该子查询必须是一个单一的查询，不能是UNION连接起来的若干个查询</li><li>子查询不能包含GROUP BY、HAVING语句或者聚集函数</li></ul><p>不适用半连接的情况</p><ul><li><p>在外层查询的WHERE子句中，存在其他搜索条件使用OR操作符与IN子查询组成的布尔表达式连接起来的情况</p><p><code>SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;) OR key2 &gt; 100&#39;</code></p></li><li><p>使用NOT IN而不是IN的情况</p><p><code>SELECT * FROM s1 WHERE key NOT IN (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;);</code></p></li><li><p>位于SELECT子句中的IN子查询的情况</p><p><code>SELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;) FROM s1;</code></p></li><li><p>子查询中包含GROUP BY、HAVING或者聚集函数的情况</p><p><code>SELECT * FROM s1 WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);</code></p></li><li><p>子查询中包含UNION的情况</p></li></ul><p>对于不能转为半连接的子查询，MYSQL使用如下两个方法优化：</p><ul><li><p>对于不相关的子查询，尝试把他们物化之后再参与查询</p><p><code>SELECT * FROM s1 WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;);</code></p></li><li><p>无论子查询是相关的还是不相关的，都可以尝试转为EXISTS子查询</p><p>&#x2F;&#x2F; 没看懂</p></li></ul></li></ol><h4 id="3-ANY-x2F-ALL-子查询优化"><a href="#3-ANY-x2F-ALL-子查询优化" class="headerlink" title="3. ANY&#x2F;ALL 子查询优化"></a>3. ANY&#x2F;ALL 子查询优化</h4><p>如果ANY&#x2F;ALL子查询时不相关子查询，很多场合下都可以转换执行</p><table><thead><tr><th>原始表达式</th><th>转换为</th></tr></thead><tbody><tr><td>&lt; ANY (SELECT inner_expr…)</td><td>&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td>&gt; ANY (SELECT inner_expr …)</td><td>&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&lt; ALL (SELECT inner_expr…)</td><td>&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&gt; ALL (SELECT inner_expr …)</td><td>&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h4 id="4-NOT-EXISTS-子查询的执行"><a href="#4-NOT-EXISTS-子查询的执行" class="headerlink" title="4. [NOT]EXISTS 子查询的执行"></a>4. [NOT]EXISTS 子查询的执行</h4><p>如果[NOT]EXISTS子查询时不相关子查询，可以先执行子查询，得出[NOT]EXISTS子查询的结果是TRUE还是FALSE，然后重写原先的查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">OR</span> key2 <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重写为</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line"><span class="keyword">WHERE</span> <span class="literal">TRUE</span></span><br><span class="line"><span class="keyword">OR</span> key2 <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h4 id="5-对于派生表的优化"><a href="#5-对于派生表的优化" class="headerlink" title="5. 对于派生表的优化"></a>5. 对于派生表的优化</h4><p>将子查询放在外层的FROM后，这个子查询相当于一个派生表，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> id <span class="keyword">AS</span> d_id, key3 <span class="keyword">AS</span> d_key3 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> derived_s1 <span class="keyword">WHERE</span> d_key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>对于含有派生表的查询，MySQL提供两种执行策略</p><ul><li><p>把派生表物化</p></li><li><p>将派生表和外层查询合并（查询重写成没有派生表的形式）</p><p>如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">AS</span> derived_s1 </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 </span><br><span class="line"><span class="keyword">ON</span> derived_s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line">  <span class="keyword">WHERE</span> s2.key <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>将派生表与外层查询合并，将派生表的搜索条件放到外层查询的搜索条件中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line"><span class="keyword">WHERE</span> s1.key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> s2.key2 <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 优化 </tag>
            
            <tag> 查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB统计数据是如何收集的 - 《MySQL是怎样运行的》ch13</title>
      <link href="/2022/10/22/2022-10-22%20InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/"/>
      <url>/2022/10/22/2022-10-22%20InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch13-InnoDB统计数据是如何收集的"><a href="#Ch13-InnoDB统计数据是如何收集的" class="headerlink" title="Ch13 InnoDB统计数据是如何收集的"></a>Ch13 InnoDB统计数据是如何收集的</h1><p>查询成本中存在一些统计数据，例如<code>SHOW TABLE STATUS</code>查看表的统计数据</p><p>本章聚焦于InnoDB引擎的统计数据收集策略</p><h2 id="13-1-统计数据的存储方式"><a href="#13-1-统计数据的存储方式" class="headerlink" title="13.1 统计数据的存储方式"></a>13.1 统计数据的存储方式</h2><p>InnoDB提供了两种存储统计数据的方式，分别是永久性地存储统计数据和非永久性地存储统计数据</p><ul><li>永久性：统计数据存储在磁盘上</li><li>非永久：统计数据存储在内存中</li></ul><p>系统变量<code>innodb_stats_persistent</code>，用于控制统计数据存储在何处，5.6.6版本后。默认开启ON，即默认存储到磁盘上</p><p>创建表格时候指定<code>stats_persistent</code>属性指定统计数据的存储方式</p><h2 id="13-2-基于磁盘的永久性统计数据"><a href="#13-2-基于磁盘的永久性统计数据" class="headerlink" title="13.2 基于磁盘的永久性统计数据"></a>13.2 基于磁盘的永久性统计数据</h2><p>选择存储某个表以及该表格的统计数据到磁盘上，实际上将统计数据存储到两个表中中</p><img src="image-20221023225313081.png" alt="image-20221023225313081" style="zoom:50%;" /><ul><li><code>innodb_index_stats</code>存储了而关于表的统计书怒</li><li><code>innodb_table_stats</code>存储了关于索引的图片吗管控实际开</li></ul><h3 id="13-2-1-innodb-table-stats"><a href="#13-2-1-innodb-table-stats" class="headerlink" title="13.2.1 innodb_table_stats"></a>13.2.1 innodb_table_stats</h3><p>看一下innodb_table_stats表中各个列的具体作用</p><p><img src="/xkond/2022/10/22/2022-10-22%20InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/image-20221023225557239.png" alt="image-20221023225557239"></p><ul><li>Databse_name：数据库名</li><li>table_name：数据表名</li><li>Last_update：最后更新时间</li><li>n_rows：表中记录的条数</li><li>clustered_index_size：表中的聚簇索引占用的页面数量</li><li>sum_of_other_index_sizes：表中的其他索引占用的页面数量</li></ul><ol><li><p>n_rows统计项的收集</p><p>n_rows的统计值是估计值，InnoDB在统计一个表中有多少行记录时候：按照一定算法，从聚簇索引中选取一定叶子节点页面，统计每个页面中包含的记录数量，然后计算一个页面中平均包含的记录数量，乘以所有叶子节点的数量，结果就是表格的n_rows值</p><p><code>inndb_stats_persistent_sample_pages</code>系统变量表示计算统计数据时候采样的页面数量</p></li><li><p>clustered_index_size和sum_of_other_index_sizes统计项的收集</p><p>略，没看懂</p></li></ol><h3 id="13-2-2-innodb-index-stats"><a href="#13-2-2-innodb-index-stats" class="headerlink" title="13.2.2 innodb_index_stats"></a>13.2.2 innodb_index_stats</h3><p>看一下innodb_index_stats表格字段的作用</p><p><img src="/xkond/2022/10/22/2022-10-22%20InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/image-20221023230925104.png" alt="image-20221023230925104"></p><ul><li>name类型表示归属</li><li>Stat_name 统计项的名称</li><li>Stat_value 对应的统计项的值</li><li>Sample_siz 生成统计数量采样的页面数量</li><li>Stat_description 对应的统计项的描述</li></ul><p>对于一个索引有多个不同统计项，stat_name表示该索引的统计项名称</p><ul><li>n_leaf_pages 表示该索引叶子节点实际占用多少页面</li><li>size表示该作用总共占用多少页面</li><li>n_diff_pfxNN: 表示对应索引列中不重复的值有多少</li></ul><h3 id="13-2-3-定期更新统计数据"><a href="#13-2-3-定期更新统计数据" class="headerlink" title="13.2.3 定期更新统计数据"></a>13.2.3 定期更新统计数据</h3><p>MySQL提供两种更新统计数据的方式</p><ul><li><p>开启Innodb_stats_auto_recalc </p><p>该系统变量表示服务器是否自动重新计算统计数据，该功能默认开启；如果发生变动记录数据集超过了表格的10%，则自动重新计算统计数据</p></li><li><p>手动调用ANALYZE TABLE语句更新数据</p><p>手动调用以下语句计算统计数据</p><p><code>ANALYZE TABLE single_table;</code></p></li></ul><h3 id="13-3-基于内存的非永久性统计数据"><a href="#13-3-基于内存的非永久性统计数据" class="headerlink" title="13.3 基于内存的非永久性统计数据"></a>13.3 基于内存的非永久性统计数据</h3><p>当把系统变量<code>innodb_stats_persistent</code>设置为OFF后，之后创建的表的统计数据就默认为非永久性的</p><p>不过最近MySQL版本不怎么使用这种方式了</p><h2 id="13-4-innodb-stats-method的使用"><a href="#13-4-innodb-stats-method的使用" class="headerlink" title="13.4 innodb_stats_method的使用"></a>13.4 innodb_stats_method的使用</h2><p>索引列中不重复的值对于MySQL优化器非常重要，计算索引列中一个值平均重复多少行；如以下两个场景</p><ul><li>单表查询的单点扫描区间太多</li><li>执行连接查询时，如果设计两个表的等值匹配连接条件，且连接条件对应的被驱动表中拥有索引时，可以使用ref访问方法查询被驱动表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基于成本的优化 -《MySQL是怎样运行的》ch12</title>
      <link href="/2022/09/25/2022-09-25%20MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2022/09/25/2022-09-25%20MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch12-基于成本的优化"><a href="#Ch12-基于成本的优化" class="headerlink" title="Ch12 基于成本的优化"></a>Ch12 基于成本的优化</h1><h2 id="12-1-什么是成本"><a href="#12-1-什么是成本" class="headerlink" title="12.1 什么是成本"></a>12.1 什么是成本</h2><p>MySQL执行一个查询的时候可以有不同的执行方案，通常会采用成本最小的</p><p>执行的成本是由两个方面组成的</p><ul><li>I&#x2F;O成本：数据和索引通常是保存在磁盘上的，从磁盘加载到内存的过程损耗称为I&#x2F;O成本</li><li>CPU成本：读取记录以及监测记录是否满足对应的搜索条件、对结果集进行排序等操作损耗时间称为CPU成本</li></ul><h2 id="12-2-单表查询的成本"><a href="#12-2-单表查询的成本" class="headerlink" title="12.2 单表查询的成本"></a>12.2 单表查询的成本</h2><h3 id="12-2-1-12-2-2-基于成本的优化"><a href="#12-2-1-12-2-2-基于成本的优化" class="headerlink" title="12.2.1| 12.2.2 基于成本的优化"></a>12.2.1| 12.2.2 基于成本的优化</h3><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  KEY idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_key2 (key2),</span><br><span class="line">  key idx_key3 (key3),</span><br><span class="line">  key idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>在真正执行一条单表查询语句之前，MySQL的优化器会找到所有可以用来执行该语句的方案，并在对比这些方案之后找出成本最低的方案，过程是这样的：</p><ol><li><p>根据搜索条件，找出所有可能的索引；</p></li><li><p>计算全表扫描的代价；</p></li><li><p>计算使用不同索引执行查询的代价；</p></li><li><p>对比执行方案的代价，找出成本代价最低的那个方案。</p></li></ol><p>如果有这样一条单表查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> </span><br><span class="line">key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line">key2 <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> key2 <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">AND</span></span><br><span class="line">key3 <span class="operator">&gt;</span> key2 <span class="keyword">AND</span></span><br><span class="line">key_part1 <span class="keyword">LIKE</span> <span class="string">&#x27;%hello%&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">common_field <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li><p>根据搜索条件，找出所有可能的索引</p><p>上面的查询语句可以用到</p><p>Idx_key1二级索引、uk_key2二级索引</p></li><li><p>计算全表扫描的代价</p><p>查询成本 &#x3D; I&#x2F;O成本 + CPU成本，所以判断代价需要信息：</p><ol><li>聚簇索引占用的页面数；</li><li>该表格中的记录数</li></ol><p>这些记录可以执行语句查看执行统计信息</p><p><code>SHOW TABLE STATUS LIKE &#39;single_table&#39;\G;</code></p><p>其中，Rows表示表中的记录条数，注意，对于InnoDB来说这是一个估计值</p><p>Data_length表示表占用的存储空间字节数，对于InnoDB来说，该值相当于聚簇索引占用的存储空间大小</p><p><code>Data_length = 聚簇索引的页面数量 * 每个页面大小（默认16kb）</code></p><p>计算成本：</p><ul><li>I&#x2F;O成本：97（页面数量）* 1.0（成本常数） + 1.1（微调值）</li><li>CPU成本：9693（Rows记录数） * 0.2（成本常数） + 1.0（微调值）</li><li>总成本：I&#x2F;O成本 + CPU成本</li></ul></li><li><p>计算不同索引执行查询的代价</p><p>需要首先单独分析索引执行查询的成本，最后分析是否可能使用到索引合并。MySQL会先分析使用唯一二级索引的成本，再分析普通索引的成本</p><ol><li><p>使用uk_key2的执行成本</p><p>这部分查询成本依赖两方面数据：</p><ul><li><p>扫描区间数量</p><p>优化器会认为一个扫描区间与读取一个页面的I&#x2F;O成本是相同的，认为I&#x2F;O的成本就是 1 x 1.0 &#x3D; 1.0</p><p>读取记录的CPU成本是 95 * 0.2</p></li><li><p>需要回表的记录数量</p><p>预计有95条数据需要进行回表操作，回表带来的I&#x2F;O成本就是 95 x 1.0 &#x3D; 95.0， 1.0认为是一个I&#x2F;O操作的成本常数</p><p>回表后得到完整的用户记录，然后判断其他搜索条件是否成立，CPU成本是 95 * 0.2 &#x3D; 19.0</p></li><li><p>总成本：<br>I&#x2F;O成本：1.0 + 95 * 1.0 &#x3D; 96</p><p>CPU成本：95 * 0.2 + 0.01 + 95 * 0.2 &#x3D; 38.01</p><p>总成本 &#x3D; 96.0 + 38.01 &#x3D; 134.01</p></li></ul></li><li><p>使用idx_key1的执行成本</p><p>计算方法同上</p><ul><li><p>扫描区间数量</p><p>in (‘a’, ‘b’, ‘c’) 可以认为有三个扫描区间，I&#x2F;O成本&#x3D; 3 * 1.0 &#x3D; 3.0</p></li><li><p>需要回表数量</p><p>总共的回表数量 35 + 44 + 39 &#x3D; 118读取的CPU成本 &#x3D; 118 * 0.2 + 0.01 &#x3D; 23.61</p><p>回表的I&#x2F;O成本是 118 * 1.0 &#x3D; 118.0</p><p>搜索回表后的条件CPU成本 118 * 0.2 &#x3D; 23.6</p></li><li><p>总成本 &#x3D; 168.21</p></li></ul></li><li><p>判断是否可能使用索引合并</p><p>本例子不能使用索引合并</p></li></ol><p>本例子中可以得到查询成本最低的是uk_key2，选择该索引执行查询</p></li></ol><h3 id="12-2-3-基于索引统计数据的成本计算"><a href="#12-2-3-基于索引统计数据的成本计算" class="headerlink" title="12.2.3 基于索引统计数据的成本计算"></a>12.2.3 基于索引统计数据的成本计算</h3><p>如果查询中有许多单点扫描区间，需要进行index dive操作，性能损耗极大</p><p>MySQL提供了一个系统变量<code>eq_range_index_dive_limit</code>，如果大于系统变量的设置值，就不使用index dive了</p><p>可以使用<code>SHOW INDEX FROM 表名;</code> 查看索引的统计数据，</p><ul><li>其中最重要是Cardinality属性，表示该列中不重复的值的个数，这个值是一个估计值</li><li>如果单点扫描区间数量超过系统变量<code>eq_range_index_dive_limit</code>，则使用平均每个值重复多少次（row &#x2F; Cardinality ），乘扫描区间数量估计回表次数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL连接 -《MySQL是怎样运行的》ch11</title>
      <link href="/2022/09/25/2022-09-25%20MySQL%E8%BF%9E%E6%8E%A5/"/>
      <url>/2022/09/25/2022-09-25%20MySQL%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch-11-两个表的亲密接触——连接的原理"><a href="#Ch-11-两个表的亲密接触——连接的原理" class="headerlink" title="Ch 11 两个表的亲密接触——连接的原理"></a>Ch 11 两个表的亲密接触——连接的原理</h1><p>关系型数据库中有个重要概念是Join（连接），但是通常存在两个误区</p><ul><li><p>复杂的查询在一个连接语句中处理</p></li><li><p>连接导致慢查询</p></li></ul><h2 id="11-1-连接简介"><a href="#11-1-连接简介" class="headerlink" title="11.1 连接简介"></a>11.1 连接简介</h2><h3 id="11-1-1-连接的本质"><a href="#11-1-1-连接的本质" class="headerlink" title="11.1.1 连接的本质"></a>11.1.1 连接的本质</h3><p>从本质上说，连接就是把各个表格中的记录都取出来进行依次匹配，并把匹配后的组合发送给客户端。</p><img src="image-20220925145803084.png" alt="image-20220925145803084" style="zoom:50%;" /><p>如果连接查询的结果集包含一个表中的每一条集合与另外一个表格中的每一条记录相互匹配的组合，那么这样的结果集就可以称为笛卡尔积。</p><h3 id="11-1-2-连接过程简介"><a href="#11-1-2-连接过程简介" class="headerlink" title="11.1.2 连接过程简介"></a>11.1.2 连接过程简介</h3><p>如果不附加任何条件的连接产生的笛卡尔积可能是非常巨大的。所以最好是在连接时候过滤掉特定的组合。</p><p>连接查询的过滤条件可以分为两种</p><ul><li>涉及单个表格的条件</li><li>涉及两个表格的条件：例如t1.m1 &#x3D; t2.m2</li></ul><p>例如下面这个查询语句</p><p><code>SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 &gt; t2.m2 AND t2.n2 &lt; &#39;d&#39;;</code></p><p>连接的执行过程如下：</p><p><strong>Step1</strong>. 首先确定第一个查询的表，这个表格称为驱动表格，选取代价最低的单表访问方法来执行对驱动表的单表查询</p><p><strong>Step2</strong>. 步骤1中从驱动表中每获取到一条记录，都需要到t2表格中查找匹配的记录</p><img src="image-20220925151857783.png" alt="image-20220925151857783" style="zoom: 33%;" /><blockquote><p>注意流程是每获得一条驱动表数据，就立即到被驱动表格中寻找匹配的数据</p><p>所以在连接查询中，驱动表只需要访问一次，被驱动表需要访问多次</p></blockquote><h3 id="11-1-3-内连接和外连接"><a href="#11-1-3-内连接和外连接" class="headerlink" title="11.1.3 内连接和外连接"></a>11.1.3 内连接和外连接</h3><p>内连接和外连接的概念：</p><ul><li>对于内连接的两个表，若驱动表中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集</li><li>对于外连接的两个表，即时驱动表的数据在被驱动表中没有匹配的记录，也仍然需要加入到结果集</li></ul><p>在MySQL中，根据选取的驱动表的不同，外连接可以细分为两种</p><ul><li>左外连接：选取左边的表格作为驱动表</li><li>右外连接：选取右边的表格作为驱动表</li></ul><p>对于外连接不需要加入结果集的的数据需要添加过滤条件，过滤条件在不同的地方存在不同语义</p><ul><li><p>WHERE子句中的过滤条件</p><p>凡是不符合WHERE子句条件的记录都不会被加入到最后的结果集</p></li><li><p>ON子句中的过滤条件<br>对于外连接的驱动表中的数据来说，如果无法在被驱动表中找到匹配ON子句中过滤条件的记录，那么那么该驱动表记录仍然会被加入到接过去，但是被驱动表的字段使用NULL填充</p><p>内连接的WHERE子句和ON子句是等价的</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="11-2-连接的原理"><a href="#11-2-连接的原理" class="headerlink" title="11.2 连接的原理"></a>11.2 连接的原理</h2><h3 id="11-2-1-嵌套循环连接"><a href="#11-2-1-嵌套循环连接" class="headerlink" title="11.2.1 嵌套循环连接"></a>11.2.1 嵌套循环连接</h3><p>前面提到过两个表的连接操作</p><img src="image-20220925155652966.png" alt="image-20220925155652966" style="zoom:30%;" /><p>如果有三个表进行连接，那就是使用前两个表连接得到的结果集作为新的驱动表</p><p>第3个表作为被驱动表，重复上述的过程</p><p>这就像是一个嵌套的循环，这种连接执行方式称为嵌套循环连接，是最简单也是最笨拙的一种连接算法</p><h3 id="11-2-2-使用索引加快连接速度"><a href="#11-2-2-使用索引加快连接速度" class="headerlink" title="11.2.2 使用索引加快连接速度"></a>11.2.2 使用索引加快连接速度</h3><p>对于驱动表创建索引可以加快单表访问方法的性能</p><p>同时可以对于被驱动表格创建索引，同样根据过滤条件选择创建索引，加快访问的速度</p><h3 id="11-2-3-基于块的嵌套循环连接"><a href="#11-2-3-基于块的嵌套循环连接" class="headerlink" title="11.2.3 基于块的嵌套循环连接"></a>11.2.3 基于块的嵌套循环连接</h3><p>对于被驱动表非常大的场景，多次访问驱动表可能导致大量的磁盘I&#x2F;O</p><p>使用基于块的嵌套循环算法优化</p><p>将若干条驱动表的数据存在Join buffer（连接缓冲区）中，将被驱动表一次与多个驱动表记录进行匹配</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> MySQL文件目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL全文检索</title>
      <link href="/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
      <url>/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL全文索引"><a href="#MySQL全文索引" class="headerlink" title="MySQL全文索引"></a>MySQL全文索引</h1><p>MySQL支持全文索引和全文检索（版本大于5.6）</p><ul><li>全文索引在MySQL中是索引类型<code>FULLTEXT</code></li><li>全文索引只能在InnoDB和MyISAM引擎中使用，并且只能在<code>CHAR</code>,<code>VARCHAR</code>或者<code>TEXT</code>列中创建</li><li>MySQL内置全文ngram解析器，支持中文、韩文、日文（MySQL版本大于5.7.6之后）</li><li><code>FULLTEXT</code>索引能够在创建表的<code>CREATE TABLE</code>时候声明，也可以使用<code>ALTER TABLE</code>或者<code>CREATE INDEX</code>创建</li><li>对于大数据集而言，比起不使用全文索引，创建全文索引检索数据的数据要快得多</li></ul><p>全文检索需要使用<code>MATCH() AGAINST()</code>语法，<code>MATCH()</code>接收一个逗号分割的列表包含需要被搜素的列名称。<code>AGAINST()</code>接收一个需要搜索的字符，和一个用于说明搜索形式的可选项</p><p>存在三种不同类型的全文检索</p><ul><li>Natural language 检索意为检索自然语言的短语，这种类型的没有特殊的操作</li><li>Boolean检索意为检索字符串使用特殊的查询语法。字符串包含需要用于搜索的词汇。</li><li>Query expansion检索是一种自然语言检索的变种</li></ul><h2 id="自然语言全文检索"><a href="#自然语言全文检索" class="headerlink" title="自然语言全文检索"></a>自然语言全文检索</h2><p>默认情况下或者使用<code>IN NATURAL LANGUAGE MODE</code>语句情况下，<code>MATCH()</code>函数表现为在文本集合中对字符进行检索自然语言检索。文本集合是一个或者多个创建了<code>FULLTEXT</code>索引的数据列</p><p>被检索的文本作为<code>AGAINST()</code>函数接收的参数。</p><p>对于数据表的每一行，<code>MATCH()</code>函数返回相关的值，也就是说，搜索字符串与 MATCH() 列表中命名的列中该行中的文本之间的相似性度量。</p><h3 id="创建和使用全文索引"><a href="#创建和使用全文索引" class="headerlink" title="创建和使用全文索引"></a>创建和使用全文索引</h3><p>创建示例表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `articles` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `body` text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  FULLTEXT KEY `title` (`title`,`body`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="comment">-- 或者alter语法</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `articles` <span class="keyword">ADD</span> INDEX FULLTEXT `title` (`title`, `body`);</span><br></pre></td></tr></table></figure><p>一个查询如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> articles (title, body) <span class="keyword">VALUES</span>  </span><br><span class="line">(<span class="string">&#x27;MySQL Tutorial&#x27;</span>, <span class="string">&#x27;DBMS stands for DataBase ..,&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;How To Use MySQL Well&#x27;</span>, <span class="string">&#x27;After you went through a ...&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Optimizing MySQL&#x27;</span>, <span class="string">&#x27;In this tutorial, we show ...&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1001 MySQL Tricks&#x27;</span>, <span class="string">&#x27;1. Never run mysqld as root. 2. ...&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;MySQL vs. Your SQL&#x27;</span>, <span class="string">&#x27;In the following database comparison ...&#x27;</span>), </span><br><span class="line">(<span class="string">&#x27;MySQL Security&#x27;</span>, <span class="string">&#x27;When configured properly, MySQL ...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, body) AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br></pre></td></tr></table></figure><h3 id="相关性的计算"><a href="#相关性的计算" class="headerlink" title="相关性的计算"></a>相关性的计算</h3><p>相关性的计算基于：</p><ul><li>列的给定行中的单词；</li><li>该行中唯一的单词；</li><li>文本中的字数；</li><li>包含单个单词的行。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>默认情况下，搜索是以不区分大小写的形式执行的。如果需要区分大小写的检索，需要对索引列使用binary collation。</p><p>当在WHERE中使用<code>MATCH()</code>函数的时候，返回的数据自动根据文本相似度程度返回，需要满足以下情况</p><ul><li>必须没有明确的<code>ORDER BY</code>语句</li><li>检索语句必须使用全文索引而不是全表扫描</li><li>如果连表，全文索引扫描必须是连接最左的非常量表</li></ul><p>因此，如果需要对于结果进行排序，通常需要较大的精力</p><p>相似度是非负的浮点数。关联为0意为着没有相似度。计算关联度是基于行（文档）中的单词数计算的，在行中唯一单词的数量，集合中的单词总数，以及包含特定词汇的行的数量</p><p>简单的计算匹配的数量，可以使用下面的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> articles</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>也可以使用以下的方式重写查询请求</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="built_in">COUNT</span>(IF(<span class="keyword">MATCH</span> (title,body) AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE), <span class="number">1</span>, <span class="keyword">NULL</span>))</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span> count</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> articles;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span> count <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>第一个查询请求做了一些额外的工作（根据相似度结果排序），但也可以使用基于WHERE子句。如果搜索匹配几行，索引查找可能会使第一个匹配更快</p><p>第二个查询使用了全表扫描，如果搜索词出现在大多数行中，可能比索引查找更快</p><p>自然语言全文索引，在<code>MATCH()</code>函数中出现的列名必须和创建全文索引的<code>FULLTEXT</code>的数据列同名。</p><p>如同表中，只能同时检索title和body的列，如果只想要检索某一个列，则需要重新创建一个<code>FULLTEXT</code>索引</p><p>全文索引只能够对于一个表中的列进行操作，因为创建索引不能够跨越多个数据表。</p><p>同样可以打印具体的相似度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> id, <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> AGAINST (<span class="string">&#x27;Tutorial&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE) <span class="keyword">AS</span> score</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> articles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> score               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">0.22764469683170319</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>                   <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> <span class="number">0.22764469683170319</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span>                   <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span>                   <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span>                   <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>更复杂的例子。该查询换回相似度同时倒序排序。为了达成结果，需要使用<code>MATCH</code>两次，一次在SELECT列表中，一次在WHERE子句中。这并不会导致额外的开销，因为MySQL优化器注意到两个MATCH()调用是相同的，只会执行一次全文搜索代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> id, body, <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   AGAINST (<span class="string">&#x27;Security implications of running MySQL as root&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE) <span class="keyword">AS</span> score</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> articles</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body) </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   AGAINST(<span class="string">&#x27;Security implications of running MySQL as root&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> body                                <span class="operator">|</span> score           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> <span class="number">1.</span> Never run mysqld <span class="keyword">as</span> root. <span class="number">2.</span> ... <span class="operator">|</span> <span class="number">1.5219271183014</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> <span class="keyword">When</span> configured properly, MySQL ... <span class="operator">|</span> <span class="number">1.3114095926285</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------------------------+-----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>全文索引引擎将短语划分为词，同时在全文索引中检索相关词汇。</p><p>非单词词汇不需要完全匹配，短语搜索只要求匹配包含与短语完全相同的单词并且顺序相同。举个例子，’test phrase’匹配’test, phrase’，如果短语不包含任何在索引中的词汇，返回结果是为空。</p><p>MySQL FULLTEXT实现将任何短语视为一个单词（字母、数字、下划线），也可以编写一个插件代替原生的全文解析器</p><p>一些词汇在全文索引中会被忽略</p><ul><li><p>任何单词如果过短都会被忽略。全索引能够找到的最短单词长度对于InnoDB是三个字符，对于MyISAM是四个字符。可以通过在创建索引前配置变量：对于InnoDB是<code>innodb_ft_min_token_size</code>，对于MyISAM是<code>ft_min_word_len</code></p><blockquote><p>此行文不适用与使用ngram解析器的全文索引。对于使用全文索引解析器的，分词长度有<code>ngram_token_size</code>选项定义</p></blockquote></li><li><p>单词位于停用词列表的会被忽略。一些常用的词例如’the’或’some’会被认为0语义。存在一个内置的停用词列表，但同时它也可以被用户定义的列表覆盖。停用词处理由配置选项控制，<code>innodb_ft_enable_stopword</code>,<code>innodb_ft_server_stopword_table</code>和<code>innodb_ft_user_stopword_table</code>用于InnoDB索引搜索，还有<code>ft_stopword_file</code>用于MyISAM引擎</p></li></ul><p>集合和查询中每个单词都根据其在集合或者查询中的重要性进行加权。因此，出现在许多文档中的词具有较低的权重，如果单词很少见，会获得更高的权重。</p><h2 id="布尔全文搜索"><a href="#布尔全文搜索" class="headerlink" title="布尔全文搜索"></a>布尔全文搜索</h2><p><code>IN BOOLEAN MODE</code></p><p>MySQL可以使用修饰符执行布尔全文搜索，使用此修饰符，+和-运算符分别表示单词必须存在或者不存在，才能发生匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> AGAINST (<span class="string">&#x27;+MySQL -YourSQL&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure><blockquote><p>其中隐含了一些逻辑</p><ul><li>+代表AND</li><li>-代表NOT</li><li>无运算符暗示 OR</li></ul></blockquote><p>布尔全文搜索具有以下特征</p><ul><li>中文的最小文字参数有ngraam_token_size选项定义</li><li>不支持对单个搜索词使用多个运算符</li></ul><h2 id="带有查询拓展的全文搜索"><a href="#带有查询拓展的全文搜索" class="headerlink" title="带有查询拓展的全文搜索"></a>带有查询拓展的全文搜索</h2><p><code>WITH QUERY EXTENSION</code></p><p>这一种方式，通过执行两次搜索，来工作，其中第二次搜索是根据第一搜索结果的关联词汇进行搜索，因此可以搜索得到与原本数据不一样的文本</p><p>例如：原本第一次查询仅仅只查询database，但是第一次查询的结果包含MySQL，所以with query extension的第二次搜索会使用database和mysql进行检索</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title             <span class="operator">|</span> body                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> MySQL Tutorial    <span class="operator">|</span> DBMS stands <span class="keyword">for</span> DataBase ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> MySQL vs. YourSQL <span class="operator">|</span> <span class="keyword">In</span> the following database comparison ... <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">WITH</span> QUERY EXPANSION);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title                 <span class="operator">|</span> body                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> MySQL vs. YourSQL     <span class="operator">|</span> <span class="keyword">In</span> the following database comparison ... <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> MySQL Tutorial        <span class="operator">|</span> DBMS stands <span class="keyword">for</span> DataBase ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Optimizing MySQL      <span class="operator">|</span> <span class="keyword">In</span> this tutorial we <span class="keyword">show</span> ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> MySQL Security        <span class="operator">|</span> <span class="keyword">When</span> configured properly, MySQL ...      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> How <span class="keyword">To</span> Use MySQL Well <span class="operator">|</span> After you went through a ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> <span class="number">1001</span> MySQL Tricks     <span class="operator">|</span> <span class="number">1.</span> Never run mysqld <span class="keyword">as</span> root. <span class="number">2.</span> ...      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------------+------------------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="ngram-全文解析器"><a href="#ngram-全文解析器" class="headerlink" title="ngram 全文解析器"></a>ngram 全文解析器</h2><p>对于中文、日文韩文等语种，MySQL提供了ngram全文解析器，InnoDB和MyISAM都支持</p><p>Ngram方法是将所有的文本序列进行分割成为n个连续的字符串，例如，可以将”浙江温州”进行不同的拆分解析</p><blockquote><p>n&#x3D;1: 浙 江 温 州</p><p>n&#x3D;2: 浙江 江温 温州</p><p>n&#x3D;3: 浙江温 江温州</p><p>n&#x3D;4: 浙江温州</p></blockquote><h3 id="配置ngram分词大小"><a href="#配置ngram分词大小" class="headerlink" title="配置ngram分词大小"></a>配置ngram分词大小</h3><p>默认配置的ngram切分是2，通过配置<code>ngram_token_size</code>配置选项进行设置，最小值为1，最大值为10</p><p><code>ngram_token_size</code>是只读变量，只能设置启动字符串的一部分或者配置文件</p><p><strong>注意，对于查询中小于最小分词大小的词不会找到任何结果</strong></p><h3 id="创建使用ngram解析器的FULLTEXT索引"><a href="#创建使用ngram解析器的FULLTEXT索引" class="headerlink" title="创建使用ngram解析器的FULLTEXT索引"></a>创建使用ngram解析器的FULLTEXT索引</h3><p>对于使用中文的全文索引，需要带上<code>WITH PARSER ngram</code>字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">      id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">      title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">      body TEXT,</span><br><span class="line">      FULLTEXT (title,body) <span class="keyword">WITH</span> PARSER ngram</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br><span class="line"><span class="comment">-- 或者使用修改语句</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> articles <span class="keyword">ADD</span> FULLTEXT INDEX ft_index (title,body) <span class="keyword">WITH</span> PARSER ngram;</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>测试使用微信公众号数据:<a href="https://github.com/nonamestreet/weixin_public_corpus">https://github.com/nonamestreet/weixin_public_corpus</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试用SQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> articles (id, title, body, created_time, updated_time)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">NULL</span>, <span class="string">&#x27;武术礼仪&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;武术礼仪是习武者应共同遵守的最基本的道德行为规范是习武之人文明礼貌的一种体现。国际武术联合会规定的武术礼仪是中国传统的一种武术礼节，本着当代武术为和平与友谊服务的宗旨，寓意天下武林是一家。\n徒手礼\n1、抱拳礼\n（1）行礼的方法：并步站立，右手成拳，左手四指并拢伸直成掌，拇指屈拢，左掌心掩贴右拳面（左指根线与右拳棱相齐），左指尖与下颏平齐，右掌眼斜对胸窝，置于胸前屈臂成圆，肘尖略下垂，拳掌与胸相距20-30厘米。头正、身直、目视受礼者，面容举止大方。\n（2）抱拳礼的涵义：左掌声表示德、智、体、美“四育”齐备，屈拇指表示不自大，右掌表示勇武顽强，左掌掩右拳，表示“勇不滋事”、“武不犯禁“：左掌右拳拢屈，两臂环抱成圆，表示五湖四海，天下武林是一家，以武会友；左掌为文，右拳为武，表示文武兼备。\n（3）抱拳礼的应用 在武术竞赛、表演、训练活动中应用。\n2、鞠躬礼\n（1）行礼的方法 并步站立，两手垂置于体侧，手心向内贴于大腿外侧，上体向前倾斜15度。\n（2）鞠躬礼的应用\nA、见到师长或领导时使用此礼；\nB、表演、比赛演练结束时使用此礼；\nC、不适于应用抱拳礼的正规场合。\n持械礼\n1、抱刀礼\n并步站立，左手抱刀，屈臂使刀斜横于胸前，刀背贴于小臂上，刀刃向上，右手拇指屈拢成斜侧立掌，以掌根附于左腕内侧，两腕部与锁窝同高，两臂外撑，肘略低于手，目视受礼者。\n2、持剑礼\n并步站立，左手抱剑，屈臂使剑身贴于小臂外侧，斜横于胸前，右手拇指屈拢成斜侧立掌，以掌根附于左腕内侧，两腕部与锁窝同高，两臂外撑，肘略低于手，目视受礼者。\n3、持枪（棍）礼\n并步站立，右（左）手枪（棍）把端三分之一处，屈臂置于胸前，枪（棍）身直立，枪尖（棍梢）向上，左（右）手拇指屈拢成斜侧立掌，以掌根附于右（左）腕内侧，两臂外撑，肘略低于手，目视受礼者。 抱刀礼、持剑礼、枪（棍）礼一般在武术的竞赛、表演、训练活动中应用。\n场所\n（一）武术竞赛场所\n1、举行武术竞赛活动时，应有升、降国旗的仪式。在升国旗时应唱（奏）国歌，全体在场人员应面对国旗肃立，行注目礼。\n2、如无升降国旗仪式，也可事先将国旗悬挂在赛场的适当位置。在竞赛开始时，举行面对国旗、肃立唱（奏）国歌的仪式。\n（二）武术训练场所\nl、在适当位置悬挂国旗。\n2、在适当位置悬挂中国武术协会会徽。\n3、在适当位置张贴中国武术协会颁布的“武德守则”和“习武十戒”。\n4、从武人员进入和离开训练馆时，必须向国旗行鞠躬礼；运动员（学生）还必须向教练员（教师）行抱拳礼。\n传统武礼\n先是左脚上步，右脚跟上并步站直，意为视对方为尊。再步上前，以表示敬仰；左手四指伸直意为练武之人应该艺德齐备，拇指弯曲意为不逞强不做大。\n两臂平颌环抱当胸拢成圆意为五湖四海天下武林是一家；掌为文拳为武，右拳紧握抵于左掌中指端意为武不犯禁，勇不滋乱，就文止武。两手手心向上外推，意为有缘相会是朋友，来请师友前辈指教，拳眼向胸意为友情记心中；两手高举过头为至礼，表示对对方佩服的五体投地。\n两手相抵，出声为响拳，表示心急意切，情绪激烈；抱拳四面环绕为罗圈礼，是对众人的大礼；若抱拳于左胸为武礼，意为晏文就武，以拳说话，准备开打了。\n教学礼节\n武术礼仪-教学礼节\n武术课堂是一个严肃的教育场所。师生要用武术礼仪的标准来约束自己，言行有礼。\n1．技术教学、训练礼节\n上课铃响时，班长或值日生整队集合（同学间距约10厘米），清点人数完毕，向老师（教练）报告时，师生均行抱拳礼。老师向学生问：同学们好！的同时，行抱拳礼。学生在回答|”老师好！的同时，也行抱拳礼。然后落手立正。礼毕，上课开始。\n下课时，老师向学生说：同学们再见！，学生在答老师再见！的同时，互行抱拳礼；老师落手站立，然后学生落手立正。礼毕，师生下课。\n2．理论课堂礼节\n当老师走向讲台时，班长发口令：“起立，敬礼！”学生起立行：“鞠躬礼”。老师看学生已行礼端正，亦行“鞠躬礼”答谢。班长发口令：“坐下！”学生就坐，开始授课。\n下课时，老师说：“下课！”班长发口令：“起立，敬礼！”学生起立行“鞠躬礼”。老师看学生都已行礼端正，亦行”鞠躬礼”回谢。礼毕，下课。\n竞赛礼仪\n1．武术竞赛开幕式、闭幕式仪式\n武术比赛开幕式上，当主持人宣布大会开幕，全体人员起立面向国旗方向肃穆站立。升国旗，唱国歌。闭幕式举行降旗仪式时，全体人员唱国歌。\n2．运动员礼节\n套路运动员听到上场比赛的点名时，应向裁判长行“抱拳礼”。然后走到裁判长的右侧半场完成相同方向的起势和收势。听到宣布最后得分时，也应向裁判行“抱拳礼”，以示答谢。\n散打运动员上场当被介绍时，先面向裁判长原地行“鞠躬礼”；再转向观众行鞠躬礼。场上裁判检查护具完毕，双方运动员面对，互行“鞠躬礼”。比赛结束，双方运动员上场。当听到宣布最后胜负时，应先向裁判长行“鞠躬礼”，然后转向观众行“鞠躬礼”，再面向对手行“鞠躬礼”。\n3．裁判员礼节\n裁判员穿着统一的服装，佩带统一的裁判标志。比赛开始，广播员介绍技术监督委员会成员时，起立行“抱拳礼”；介绍仲裁委员会时，被介绍者原地行“抱拳礼”；当介绍总裁判长、裁判员时，被介绍者左脚向前一步，右脚跟上并步站立，行“抱拳礼”。礼毕，右脚后退一步，左脚向后与右脚并步站立。\n在比赛开始或结束时，当运动员向裁判长行“抱拳礼”或“鞠躬礼”时，裁判长应点头示意，以示还礼。\n表演礼节\n1。表演者在表演开始前，都应向主席台的贵宾、领导和现场观众行“抱拳礼”或“鞠躬礼”；表演结束后，行“鞠躬礼”。\n2．武术活动中，被人介绍时，应行“抱拳礼”或“鞠躬礼”。\n3．武术器械递接方法\n递接器械是武术外在形象的一个重要方面。向对方递交器械时，刀尖、剑尖向下。切忌刀尖或剑尖指向对方。枪、棍垂直离地约20厘米递给对方。切忌枪尖朝向对方，以失礼节。\n关注我们微信\n关注我们微信平台\n报名电话：18136692291\nQQ:2861709416\n地址：江苏省常州市天宁区龙锦路青竹苑B区&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;2022-09-18 15:02:01&#x27;</span>, <span class="string">&#x27;2022-09-18 15:02:01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> articles_2 (id, title, body, created_time, updated_time)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">NULL</span>, <span class="string">&#x27;武术礼仪&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;武术礼仪是习武者应共同遵守的最基本的道德行为规范是习武之人文明礼貌的一种体现。国际武术联合会规定的武术礼仪是中国传统的一种武术礼节，本着当代武术为和平与友谊服务的宗旨，寓意天下武林是一家。\n徒手礼\n1、抱拳礼\n（1）行礼的方法：并步站立，右手成拳，左手四指并拢伸直成掌，拇指屈拢，左掌心掩贴右拳面（左指根线与右拳棱相齐），左指尖与下颏平齐，右掌眼斜对胸窝，置于胸前屈臂成圆，肘尖略下垂，拳掌与胸相距20-30厘米。头正、身直、目视受礼者，面容举止大方。\n（2）抱拳礼的涵义：左掌声表示德、智、体、美“四育”齐备，屈拇指表示不自大，右掌表示勇武顽强，左掌掩右拳，表示“勇不滋事”、“武不犯禁“：左掌右拳拢屈，两臂环抱成圆，表示五湖四海，天下武林是一家，以武会友；左掌为文，右拳为武，表示文武兼备。\n（3）抱拳礼的应用 在武术竞赛、表演、训练活动中应用。\n2、鞠躬礼\n（1）行礼的方法 并步站立，两手垂置于体侧，手心向内贴于大腿外侧，上体向前倾斜15度。\n（2）鞠躬礼的应用\nA、见到师长或领导时使用此礼；\nB、表演、比赛演练结束时使用此礼；\nC、不适于应用抱拳礼的正规场合。\n持械礼\n1、抱刀礼\n并步站立，左手抱刀，屈臂使刀斜横于胸前，刀背贴于小臂上，刀刃向上，右手拇指屈拢成斜侧立掌，以掌根附于左腕内侧，两腕部与锁窝同高，两臂外撑，肘略低于手，目视受礼者。\n2、持剑礼\n并步站立，左手抱剑，屈臂使剑身贴于小臂外侧，斜横于胸前，右手拇指屈拢成斜侧立掌，以掌根附于左腕内侧，两腕部与锁窝同高，两臂外撑，肘略低于手，目视受礼者。\n3、持枪（棍）礼\n并步站立，右（左）手枪（棍）把端三分之一处，屈臂置于胸前，枪（棍）身直立，枪尖（棍梢）向上，左（右）手拇指屈拢成斜侧立掌，以掌根附于右（左）腕内侧，两臂外撑，肘略低于手，目视受礼者。 抱刀礼、持剑礼、枪（棍）礼一般在武术的竞赛、表演、训练活动中应用。\n场所\n（一）武术竞赛场所\n1、举行武术竞赛活动时，应有升、降国旗的仪式。在升国旗时应唱（奏）国歌，全体在场人员应面对国旗肃立，行注目礼。\n2、如无升降国旗仪式，也可事先将国旗悬挂在赛场的适当位置。在竞赛开始时，举行面对国旗、肃立唱（奏）国歌的仪式。\n（二）武术训练场所\nl、在适当位置悬挂国旗。\n2、在适当位置悬挂中国武术协会会徽。\n3、在适当位置张贴中国武术协会颁布的“武德守则”和“习武十戒”。\n4、从武人员进入和离开训练馆时，必须向国旗行鞠躬礼；运动员（学生）还必须向教练员（教师）行抱拳礼。\n传统武礼\n先是左脚上步，右脚跟上并步站直，意为视对方为尊。再步上前，以表示敬仰；左手四指伸直意为练武之人应该艺德齐备，拇指弯曲意为不逞强不做大。\n两臂平颌环抱当胸拢成圆意为五湖四海天下武林是一家；掌为文拳为武，右拳紧握抵于左掌中指端意为武不犯禁，勇不滋乱，就文止武。两手手心向上外推，意为有缘相会是朋友，来请师友前辈指教，拳眼向胸意为友情记心中；两手高举过头为至礼，表示对对方佩服的五体投地。\n两手相抵，出声为响拳，表示心急意切，情绪激烈；抱拳四面环绕为罗圈礼，是对众人的大礼；若抱拳于左胸为武礼，意为晏文就武，以拳说话，准备开打了。\n教学礼节\n武术礼仪-教学礼节\n武术课堂是一个严肃的教育场所。师生要用武术礼仪的标准来约束自己，言行有礼。\n1．技术教学、训练礼节\n上课铃响时，班长或值日生整队集合（同学间距约10厘米），清点人数完毕，向老师（教练）报告时，师生均行抱拳礼。老师向学生问：同学们好！的同时，行抱拳礼。学生在回答|”老师好！的同时，也行抱拳礼。然后落手立正。礼毕，上课开始。\n下课时，老师向学生说：同学们再见！，学生在答老师再见！的同时，互行抱拳礼；老师落手站立，然后学生落手立正。礼毕，师生下课。\n2．理论课堂礼节\n当老师走向讲台时，班长发口令：“起立，敬礼！”学生起立行：“鞠躬礼”。老师看学生已行礼端正，亦行“鞠躬礼”答谢。班长发口令：“坐下！”学生就坐，开始授课。\n下课时，老师说：“下课！”班长发口令：“起立，敬礼！”学生起立行“鞠躬礼”。老师看学生都已行礼端正，亦行”鞠躬礼”回谢。礼毕，下课。\n竞赛礼仪\n1．武术竞赛开幕式、闭幕式仪式\n武术比赛开幕式上，当主持人宣布大会开幕，全体人员起立面向国旗方向肃穆站立。升国旗，唱国歌。闭幕式举行降旗仪式时，全体人员唱国歌。\n2．运动员礼节\n套路运动员听到上场比赛的点名时，应向裁判长行“抱拳礼”。然后走到裁判长的右侧半场完成相同方向的起势和收势。听到宣布最后得分时，也应向裁判行“抱拳礼”，以示答谢。\n散打运动员上场当被介绍时，先面向裁判长原地行“鞠躬礼”；再转向观众行鞠躬礼。场上裁判检查护具完毕，双方运动员面对，互行“鞠躬礼”。比赛结束，双方运动员上场。当听到宣布最后胜负时，应先向裁判长行“鞠躬礼”，然后转向观众行“鞠躬礼”，再面向对手行“鞠躬礼”。\n3．裁判员礼节\n裁判员穿着统一的服装，佩带统一的裁判标志。比赛开始，广播员介绍技术监督委员会成员时，起立行“抱拳礼”；介绍仲裁委员会时，被介绍者原地行“抱拳礼”；当介绍总裁判长、裁判员时，被介绍者左脚向前一步，右脚跟上并步站立，行“抱拳礼”。礼毕，右脚后退一步，左脚向后与右脚并步站立。\n在比赛开始或结束时，当运动员向裁判长行“抱拳礼”或“鞠躬礼”时，裁判长应点头示意，以示还礼。\n表演礼节\n1。表演者在表演开始前，都应向主席台的贵宾、领导和现场观众行“抱拳礼”或“鞠躬礼”；表演结束后，行“鞠躬礼”。\n2．武术活动中，被人介绍时，应行“抱拳礼”或“鞠躬礼”。\n3．武术器械递接方法\n递接器械是武术外在形象的一个重要方面。向对方递交器械时，刀尖、剑尖向下。切忌刀尖或剑尖指向对方。枪、棍垂直离地约20厘米递给对方。切忌枪尖朝向对方，以失礼节。\n关注我们微信\n关注我们微信平台\n报名电话：18136692291\nQQ:2861709416\n地址：江苏省常州市天宁区龙锦路青竹苑B区&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;2022-09-18 15:02:01&#x27;</span>, <span class="string">&#x27;2022-09-18 15:02:01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> articles</span><br><span class="line"><span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;武术礼仪&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> articles_2</span><br><span class="line"><span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;武术礼仪&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改</span></span><br><span class="line"><span class="keyword">UPDATE</span> articles <span class="keyword">SET</span> title <span class="operator">=</span> <span class="string">&#x27;新武术礼仪&#x27;</span> <span class="keyword">WHERE</span> title <span class="operator">=</span> <span class="string">&#x27;武术礼仪&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> articles_2 <span class="keyword">SET</span> title <span class="operator">=</span> <span class="string">&#x27;新武术礼仪&#x27;</span> <span class="keyword">WHERE</span> title <span class="operator">=</span> <span class="string">&#x27;武术礼仪&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> articles</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, body) AGAINST(<span class="string">&#x27;武术礼仪&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE)</span><br><span class="line">LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> articles_2</span><br><span class="line"><span class="keyword">WHERE</span> (body <span class="keyword">LIKE</span> <span class="string">&#x27;%武术礼仪%&#x27;</span> <span class="keyword">or</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%武术礼仪%&#x27;</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id</span><br><span class="line">LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>数据量</th><th align="left">LIKE 语句</th><th>FULLTEXT索引</th></tr></thead><tbody><tr><td>50000</td><td align="left">插入：27ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093944811.png" alt="image-20220919093944811"><br />删除：9m 898ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093720969.png" alt="image-20220919093720969"><br />更新：9s 762ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093820701.png" alt="image-20220919093820701"><br />查询：12s 70ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093907567.png" alt="image-20220919093907567"></td><td>插入：51ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093418886.png" alt="image-20220919093418886"><br />删除：9s 962ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093514934.png" alt="image-20220919093514934"><br />更新：10s 102ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093605584.png" alt="image-20220919093605584"><br />查询：284ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919093617901.png" alt="image-20220919093617901"></td></tr><tr><td>10000</td><td align="left">插入：13ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094734552.png" alt="image-20220919094734552"><br />删除：2s 77ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094701555.png" alt="image-20220919094701555"><br />更新：2s 94ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094756062.png" alt="image-20220919094756062"><br />查询：1s 104ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094831165.png" alt="image-20220919094831165"></td><td>插入：42ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094726624.png" alt="image-20220919094726624"><br />删除：5s 116ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094654968.png" alt="image-20220919094654968"><br />更新：2s 34ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094806539.png" alt="image-20220919094806539"><br />查询：120ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919094822165.png" alt="image-20220919094822165"></td></tr><tr><td>5000</td><td align="left">插入：14ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095145328.png" alt="image-20220919095145328"><br />删除：489ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095214187.png" alt="image-20220919095214187"><br />更新：62ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095300790.png" alt="image-20220919095300790"><br />查询：338ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095314540.png" alt="image-20220919095314540"></td><td>插入：35ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095136606.png" alt="image-20220919095136606"><br />删除：1s 58ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095221479.png" alt="image-20220919095221479"><br />更新：98ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095253213.png" alt="image-20220919095253213"><br />查询：75ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095322078.png" alt="image-20220919095322078"></td></tr><tr><td>2000</td><td align="left">插入：12ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095428087.png" alt="image-20220919095428087"><br />删除：31ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095451409.png" alt="image-20220919095451409"><br />更新：29ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095524123.png" alt="image-20220919095524123"><br />查询：250ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095557956.png" alt="image-20220919095557956"></td><td>插入：40 ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095413854.png" alt="image-20220919095413854"><br />删除：43ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095445588.png" alt="image-20220919095445588"><br />更新：49ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095516358.png" alt="image-20220919095516358"><br />查询：114ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095542266.png" alt="image-20220919095542266"></td></tr><tr><td>1000</td><td align="left">插入：14ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095635883.png" alt="image-20220919095635883"><br />删除：18ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095703155.png" alt="image-20220919095703155"><br />更新：19ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095726434.png" alt="image-20220919095726434"><br />查询：194ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095747120.png" alt="image-20220919095747120"></td><td>插入：31ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095623697.png" alt="image-20220919095623697"><br />删除：41ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095653478.png" alt="image-20220919095653478"><br />更新：38ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095719790.png" alt="image-20220919095719790"><br />查询：71ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095739791.png" alt="image-20220919095739791"></td></tr><tr><td>500</td><td align="left">插入：13ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095846916.png" alt="image-20220919095846916"><br />删除：14ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095919420.png" alt="image-20220919095919420"><br />更新：15ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095938646.png" alt="image-20220919095938646"><br />查询：197ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919100012174.png" alt="image-20220919100012174"></td><td>插入：43ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095839360.png" alt="image-20220919095839360"><br />删除：32ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095912218.png" alt="image-20220919095912218"><br />更新：35ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919095931395.png" alt="image-20220919095931395"><br />查询：63ms<img src="/xkond/2022/09/18/2022-09-18%20MySQL%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20220919100005484.png" alt="image-20220919100005484"></td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html">https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html</a></p><p><a href="https://arctype.com/blog/mysql-search-string-like-google/">https://arctype.com/blog/mysql-search-string-like-google/</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">v</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">v</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单表访问方法 -《MySQL是怎样运行的》ch10</title>
      <link href="/2022/09/04/2022-09-04%20%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2022/09/04/2022-09-04%20%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch10-条条大路通罗马——单表访问方法"><a href="#Ch10-条条大路通罗马——单表访问方法" class="headerlink" title="Ch10 条条大路通罗马——单表访问方法"></a>Ch10 条条大路通罗马——单表访问方法</h1><p>创建这样一张表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  KEY idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_key2 (key2),</span><br><span class="line">  key idx_key3 (key3),</span><br><span class="line">  key idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h2 id="10-1-访问方法的概念"><a href="#10-1-访问方法的概念" class="headerlink" title="10.1 访问方法的概念"></a>10.1 访问方法的概念</h2><p>MySQL执行查询语句的方式称为访问方法或者访问类型。</p><p>同一个查询语句可以使用多种不同的访问方法来执行，查询结果都是一样的，但是执行花费的时间成本会相差非常多</p><h2 id="10-2-const"><a href="#10-2-const" class="headerlink" title="10.2 const"></a>10.2 const</h2><p>有时候通过主键定位一条记录</p><p><code>SELECT * FROM single_table WHERE id = 1438;</code></p><p>MySQL会直接利用主键值在聚簇索引中定位对应的用户记录</p><p><img src="/xkond/2022/09/04/2022-09-04%20%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/image-20220904171512290.png" alt="image-20220904171512290"></p><p>类似的，根据唯一二级索引定位一条记录的速度也是非常快的</p><p><code>SELECT * FROM single_table WHERE key2 = 3831;</code></p><p>这个查询的执行分为下面两步</p><ol><li>在uk_key2对应的B+树索引中，根据key2列与常数的等值比较定位到一条二级索引记录</li><li>根据该记录的id值到聚簇索引中获取完整的用户记录</li></ol><p>通过主键或者唯一二级索引索引列与常数的等值比较来定位记录的速度非常快</p><p>这种访问方法被定义为<strong>const</strong>，意味常数级别，代价可以忽略不计</p><p>另外，对于唯一索引，查询列值为NULL时候，情况比较特殊，因为不限制NULL值的数量，可能访问到多条，所以不可以使用const访问方法执行</p><p><code>SELECT * FROM single_table WHERE key2 IS NULL;</code></p><h2 id="10-3-ref"><a href="#10-3-ref" class="headerlink" title="10.3 ref"></a>10.3 ref</h2><p>将某个普通的二级索引列与常数进行等值比较，</p><p><code>SELECT * FROM single_table WHERE key1 = &#39;abc&#39;;</code></p><p>这种使用二级索引执行，形成的扫描区间为单点扫描区间，这种访问方法称为<strong>ref</strong></p><img src="image-20220904173301991.png" alt="image-20220904173301991" style="zoom:50%;" /><p>因为通过索引列进行等值比较后可能会匹配到多条二级索引记录，所以ref访问方法比const差了一点</p><p>两个注意点：</p><ul><li><p>二级索引列允许NULL值的时候，如果索引不限制NULL值的数量，执行’key IS NULL’，最多只能使用ref访问方法</p></li><li><p>对于联合索引，只要最左边连续的列是与常数进行等值比较，就可以采用ref访问方法，如</p><p><code>SELECT * FROM single_table WHERE key_part1 = &#39;god like&#39;;</code></p><p><code>SELECT * FROM single_table WHERE key_part1 = &#39;god like&#39; AND key_part2 = &#39;legendary&#39;;</code></p></li></ul><h2 id="10-4-ref-or-null"><a href="#10-4-ref-or-null" class="headerlink" title="10.4 ref_or_null"></a>10.4 ref_or_null</h2><p>不仅查找等于常数，而且找出NULL的记录</p><p><code>SELECT * FROM single_table WHERE key1 = &#39;abc&#39; OR key1 IS NULL;</code></p><p>当使用二级索引执行该查询，使用的访问方法就是<strong>ref_of_null</strong></p><p>这种访问仅仅比ref访问方法多了一些值为NULL的记录，效率稍逊一筹</p><blockquote><p>值为NULL的记录会被放在索引的最左边</p></blockquote><h2 id="10-5-range"><a href="#10-5-range" class="headerlink" title="10.5 range"></a>10.5 range</h2><p>当需要查找范围的记录时候，例如</p><p><code>SELECT * FROM single_table WHERE key2 in (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);</code></p><p>如果使用idx_key2执行查询，对应扫描区间是[1438, 1438], [6328, 6328], [38, 79]</p><p>当使用索引执行查询时，扫描区间为范围扫描区间或者多个单点，使用的访问方法是<strong>range</strong></p><h2 id="10-6-index"><a href="#10-6-index" class="headerlink" title="10.6 index"></a>10.6 index</h2><p>如下查询：</p><p><code>SELECT  key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = &#39;abc&#39;;</code></p><p>因为key_part2不是idx_key_part索引列中最左边的列，所以使用idx_key_part需要查找所有的二级索引记录</p><p>但是由于二级索引记录比聚簇索引小，同时不需要回表，这种查找会比扫描全部聚簇索引小的多，这种扫描全部二级索引记录的访问方法称为index访问方法</p><p>另外如果使用聚簇索引使用ORDER BY id，该语句会被认为认定为index访问方法</p><h2 id="10-7-all"><a href="#10-7-all" class="headerlink" title="10.7 all"></a>10.7 all</h2><p>全表扫描，扫描全部聚簇索引的执行查询的被称为all访问方法</p><h2 id="10-8-注意事项"><a href="#10-8-注意事项" class="headerlink" title="10.8 注意事项"></a>10.8 注意事项</h2><h3 id="10-8-1-略"><a href="#10-8-1-略" class="headerlink" title="10.8.1 略"></a>10.8.1 略</h3><h3 id="10-8-2-索引合并"><a href="#10-8-2-索引合并" class="headerlink" title="10.8.2 索引合并"></a>10.8.2 索引合并</h3><p>在特殊情况下，MySQL可能为多个索引生成扫描区间，使用多个索引完成一次查询的执行方法被称为索引合并</p><ol><li><p>Intersection索引合并</p><p>如下查询：</p><p><code>SELECT * FROM single_table WHERE key1 = &#39;a&#39; AND key3 = &#39;b&#39;;</code></p><p>执行时，同时使用idx_key1和idx_key3执行查询，在idx_key1中找到满足条件的二级索引记录，同时在idx_key3中找到记录，然后在二者的记录中找到id值相同的记录，然后根据共有的id值执行回表</p><p>这就是所谓的索引合并Intersection，意为交集</p><p>条件：执行这种索引合并要求二级索引查找的记录都是按照主键排序</p></li><li><p>Union索引合并</p><p>如下查询</p><p><code>SELECT * FROM single_table WHERE key1 = &#39;a&#39; OR key3 = &#39;b&#39;;</code></p><p>执行时，同时使用idx_key1和idx_key3执行查询，在idx_key1中找到满足条件的二级索引记录，同时在idx_key3中找到记录，然后在二者的记录中找到id值相同的记录，然后根据id查找并集</p><p>这就是所谓的索引合并Intersection，意为并集</p><p>条件：执行这种索引合并要求二级索引查找的记录都是按照主键排序</p></li><li><p>Sort-Union索引合并</p><p>如下的查询：</p><p><code>SELECT * FROM single_table WHERE key1 &lt; &#39;a&#39; OR key3 &gt; &#39;z&#39;;</code></p><p>因为扫描到的记录的主键不是有序的，无法使用Union索引合并，所以可以这样操作</p><ul><li>根据key &lt; ‘a’条件从idx_key1获取二级索引记录，并将二级索引记录根据主键进行排序</li><li>根据key3 &gt; ‘z’条件从idx_key3获取二级索引记录，并将二级索引记录根据主键进行排序</li><li>再进行Union索引合并回表</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的数据目录 -《MySQL是怎样运行的》ch8</title>
      <link href="/2022/08/28/2022-08-28%20MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/08/28/2022-08-28%20MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CH8-MySQL的数据目录"><a href="#CH8-MySQL的数据目录" class="headerlink" title="CH8 MySQL的数据目录"></a>CH8 MySQL的数据目录</h1><h2 id="8-1-数据库和文件系统的关系"><a href="#8-1-数据库和文件系统的关系" class="headerlink" title="8.1 数据库和文件系统的关系"></a>8.1 数据库和文件系统的关系</h2><p>一言蔽之：InnoDB和MyISAM这类存储引擎都是将数据存储在文件系统上的，文件系统是操作系统用来管理磁盘的系统</p><h2 id="8-2-MySQL的数据目录"><a href="#8-2-MySQL的数据目录" class="headerlink" title="8.2 MySQL的数据目录"></a>8.2 MySQL的数据目录</h2><h3 id="8-2-1-数据目录和安装目录的区别"><a href="#8-2-1-数据目录和安装目录的区别" class="headerlink" title="8.2.1 数据目录和安装目录的区别"></a>8.2.1 数据目录和安装目录的区别</h3><p>安装目录是存储用来控制客户端程序和服务器程序的命令，包含许多可执行文件</p><p>数据目录是用来存储MySQL在运行中产生的数据的</p><h3 id="8-2-2-确定MySQL的数据目录"><a href="#8-2-2-确定MySQL的数据目录" class="headerlink" title="8.2.2 确定MySQL的数据目录"></a>8.2.2 确定MySQL的数据目录</h3><p><code>SHOW VARIABLES LIKE &#39;datadir&#39;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;datadir&#x27;</span>;</span><br><span class="line">+---------------+--------------------------+</span><br><span class="line">| Variable_name | Value                    |</span><br><span class="line">+---------------+--------------------------+</span><br><span class="line">| datadir       | /opt/homebrew/var/mysql/ |</span><br><span class="line">+---------------+--------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.02 sec)</span><br></pre></td></tr></table></figure><h2 id="8-3-数据目录的结构"><a href="#8-3-数据目录的结构" class="headerlink" title="8.3 数据目录的结构"></a>8.3 数据目录的结构</h2><h3 id="8-3-1-数据库在文件系统中的表示"><a href="#8-3-1-数据库在文件系统中的表示" class="headerlink" title="8.3.1 数据库在文件系统中的表示"></a>8.3.1 数据库在文件系统中的表示</h3><p>每个数据库对应数据目录下的一个子目录</p><p>每当我们新建一个数据库的时候，MySQL会做以下事情：</p><ul><li>在数据目录下创建一个与数据库名同名的子目录&#x2F;文件夹</li><li>在该数据库名的子目录下创建一个名为db.opt的文件，文件包含了该数据库的一些属性</li></ul><h3 id="8-3-2-表在文件系统中的表示"><a href="#8-3-2-表在文件系统中的表示" class="headerlink" title="8.3.2 表在文件系统中的表示"></a>8.3.2 表在文件系统中的表示</h3><p>表的信息可以分为两种</p><ul><li><p>表结构的定义</p><blockquote><p>每当创建一个名为test的表格，子目录下回多出一个 test.frm文件，用来描述表结构</p></blockquote></li><li><p>表中的数据</p><ol><li><p>InnoDB是如何存储表数据</p><p>表空间（table space）或者文件空间（file space）概念。这是一个抽象概念，对应文件系统上一个或多个真实文件</p><p>表空间分为几种类型</p><ol><li><p>系统表空间</p><p>系统表空间对应一个或多个实际文件，默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdatal</code>，大小12MB的文件，</p><p>该文件就是系统表空间在文件系统上的表示</p></li><li><p>独立表空间</p><p>每一个表会建立一个独立表空间用于存储表数据（5.6.6之后版本），文件名和表名相同，添加一个.ibd拓展名</p><p>.ibd文件用于存储表数据</p><p>可以使用<code>innodb_file_per_table=0</code>配置将表数据存储到系统表空间中去</p></li><li><p>其他表空间</p><p>通用表空间（general tablespace）</p><p>undo表空间（undo tablespace）</p><p>临时表空间（temporary tablespace）</p></li></ol></li><li><p>MyISAM如何存储表数据</p><p>创建以下三个文件</p><ul><li>test.frm</li><li>test.MYD：存储用户数据</li><li>test.MYI：存储索引</li></ul></li></ol></li></ul><h3 id="8-3-3-其他文件"><a href="#8-3-3-其他文件" class="headerlink" title="8.3.3 其他文件"></a>8.3.3 其他文件</h3><p>还有以下一些文件</p><ul><li>服务器进程文件</li><li>服务器日志文件</li><li>SSL和RSA证书和秘钥文件</li></ul><h2 id="8-4-文件系统对数据库的影响"><a href="#8-4-文件系统对数据库的影响" class="headerlink" title="8.4 文件系统对数据库的影响"></a>8.4 文件系统对数据库的影响</h2><ol><li>数据库名称和表名称不得超过文件系统所允许的最大长度</li><li>特殊字符的问题</li><li>文件长度收文件系统最大长度的限制</li></ol><h2 id="8-5-MySQL系统数据库简介"><a href="#8-5-MySQL系统数据库简介" class="headerlink" title="8.5 MySQL系统数据库简介"></a>8.5 MySQL系统数据库简介</h2><ul><li>mysq：该数据库存储了MySQL的用户账户和权限信息、一些存储过程和事件的定义信息、一些日志信息、帮助信息</li><li>information_schema：保存MySQL服务器维护的所有其他数据库信息</li><li>performance_schema：保存MySQL服务器运行中的一些状态信息</li><li>sys：一个视图，帮助了解MySQL服务器的性能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> MySQL文件目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树索引的使用 -《MySQL是怎样运行的》ch7</title>
      <link href="/2022/08/20/2022-08-20%20B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/08/20/2022-08-20%20B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CH7-B-树索引的使用"><a href="#CH7-B-树索引的使用" class="headerlink" title="CH7-B+树索引的使用"></a>CH7-B+树索引的使用</h1><h2 id="7-2-索引的代价"><a href="#7-2-索引的代价" class="headerlink" title="7.2 索引的代价"></a>7.2 索引的代价</h2><ul><li>空间上的代价<br>每每建立一个索引，都要为它建立一颗B+树。每个B+树的节点都是一个数据页，每个数据页默认占用16KB组成，一颗很大的B+树由多个数据页组成，这回占用很大的一片存储空间</li><li>时间上的代价<br>增删改操作会影响节点和记录的排序，需要同时维护每个B+树索引，造成性能代价<br>在执行查询前，会指定执行计划，如果建了太多索引，会导致成本分析过程耗时太多，影响查询语句的执行性能</li></ul><h2 id="7-3-应用B-树索引"><a href="#7-3-应用B-树索引" class="headerlink" title="7.3 应用B+树索引"></a>7.3 应用B+树索引</h2><h3 id="7-3-1-扫描区间和边界条件"><a href="#7-3-1-扫描区间和边界条件" class="headerlink" title="7.3.1 扫描区间和边界条件"></a>7.3.1 扫描区间和边界条件</h3><p>执行查询最简单粗暴的方式就是搜索每一条记录，这种方式被称为<strong>全表扫描</strong></p><p>如这样一句查询语句，</p><p><code>SELECT * FROM single_table WHERE id &gt;= 2 AND id &lt;= 100;</code></p><p>能够使用索引id在[2, 100]区间中定位记录，沿着单向链表扫描，称扫描的记录的id所在区间为扫描区间，搜索的条件称为边界条件</p><blockquote><p>全表扫描的扫描区间是（负无穷，正无穷）</p></blockquote><p>在索引执行查询的时候，关键在于通过搜索条件找到合适的扫描区间，然后在对应索引中扫描区间的记录</p><p>只要索引列和常数使用&#x3D;、&lt;&#x3D;&gt;、IN、NOT IN、IS NULL、IS NOT NULL、BETWEEN、!+或者LIKE操作符连接起来，就可以产生扫描区间</p><p>注意点：</p><ul><li><p>in操作符和多个等值匹配符效果使用OR连接起来是一样的<br>例如：<br><code>SELECT * FROM single_table WHERE key2 in (1438, 6328)</code><br><code>SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328</code></p></li><li><p>LIKE操作符比较特别，只有在匹配完整的字符串或者匹配字符串前缀时才产生扫描区间<br>最左匹配原则，例如搜索条件key1 LIKE ‘a%’，对于二级索引idx_key1来说，所有字符串前缀为a的二级索引记录是相连的，只需要定位到第一个前缀为’a‘的字符就能沿着单向链表向后扫描</p></li></ul><p><strong>在若干个AND或者OR的条件生成扫描区间</strong></p><ol><li><p>所有的搜索条件都可以生成合适的扫描区间的情况</p><p>AND取交集，OR取并集</p></li><li><p>有的搜索条件不能生成合适的区间<br>例如<br><code>SELECT * FROM single_table WHERE key2 &gt; 100 OR TRUE;</code></p><p>使用idx_key2执行查询，区间也是（-∞，+∞）</p></li><li><p>复杂的搜索条件中找出扫描区间</p><p>根据一定的规则进行化简，能够使用索引的进行区间的合并，不能够的使用TRUE进行替代（每次假设使用某一个索引进行）</p></li><li><p>使用联合索引执行查询时对应的扫描区间<br>略</p></li></ol><h3 id="7-3-2-索引用于排序"><a href="#7-3-2-索引用于排序" class="headerlink" title="7.3.2 索引用于排序"></a>7.3.2 索引用于排序</h3><ol><li><p>使用联合索引进行排序的注意事项</p><p>ORDER BY字句后面的列的顺序也必须按照索引列的顺序给出</p><p><strong>ps：重点在于排序的字段在索引记录中是连续存储的</strong></p></li><li><p>不可以使用索引进行排序的几种情况</p><ol><li>ASC、DESC混用</li><li>排序列包含非同一个索引的列</li><li>排序列是某个联合索引的索引列，但是这些排序列在索引中并不连续</li><li>用来形成扫描区间的索引列与排序列不同</li><li>排序列不是以单独列名形式出现在ORDER BY字句中（使用非原始数据）</li></ol></li></ol><h3 id="7-3-3-索引用于分组"><a href="#7-3-3-索引用于分组" class="headerlink" title="7.3.3 索引用于分组"></a>7.3.3 索引用于分组</h3><p>类似于一下的分组查询语句</p><p><code>SELECT key_part1, key_part2, key_part3, COUNT(*) FROM single_table GROUP BY key_part1, key_part2, key_part3;</code></p><p>分组使用索引类似于排序，分组列的顺序需要和索引列顺序一直，也可以值使用索引类中左边连续的列进行分组</p><h2 id="7-4-回表的代价"><a href="#7-4-回表的代价" class="headerlink" title="7.4 回表的代价"></a>7.4 回表的代价</h2><p>执行回表的次数和需要查询聚簇索引的记录数据有关</p><p>如果需要执行回表的记录和次数少，优化器会倾向使用二级索引+回表</p><p>反之，如果执行回表操作的记录非常多，优化器可能会选择使用全表扫描</p><h2 id="7-5-更好的创建和使用索引"><a href="#7-5-更好的创建和使用索引" class="headerlink" title="7.5 更好的创建和使用索引"></a>7.5 更好的创建和使用索引</h2><h3 id="7-5-1-只为搜索、排序或分组的列创建索引"><a href="#7-5-1-只为搜索、排序或分组的列创建索引" class="headerlink" title="7.5.1 只为搜索、排序或分组的列创建索引"></a>7.5.1 只为搜索、排序或分组的列创建索引</h3><p>只有出现创建搜索区间的列构建索引，需要查询的数据列不需要创建索引</p><h3 id="7-5-2-考虑索引列中不重复值的个数"><a href="#7-5-2-考虑索引列中不重复值的个数" class="headerlink" title="7.5.2 考虑索引列中不重复值的个数"></a>7.5.2 考虑索引列中不重复值的个数</h3><p>如果一个索引列中重复值的个数越多，回表操作的代价就会越大，尽量使用不重复值比例较高的列构建索引</p><h3 id="7-5-3-索引列的类型尽量小"><a href="#7-5-3-索引列的类型尽量小" class="headerlink" title="7.5.3 索引列的类型尽量小"></a>7.5.3 索引列的类型尽量小</h3><p>因为索引会存储索引列的数据和主键的数据，所以索引列的类型需要尽量小，索引占用的空间越小，一个数据页可以存放更多数据，磁盘I&#x2F;O次数带来性能损耗也变小</p><p>同样主键也适用，因为所有二级索引都会存储一份记录的主键值</p><h3 id="7-5-4-为列前缀建立索引"><a href="#7-5-4-为列前缀建立索引" class="headerlink" title="7.5.4 为列前缀建立索引"></a>7.5.4 为列前缀建立索引</h3><p>当存储的字符串包含的字符较多，使用列字段字符串的前缀创建索引</p><p><code>ALTER TABLE single_table ADD INDEX idx_key1(key1(10))</code></p><h3 id="7-5-5-覆盖索引"><a href="#7-5-5-覆盖索引" class="headerlink" title="7.5.5 覆盖索引"></a>7.5.5 覆盖索引</h3><p>为了减少回表带来的性能损耗，最好在查询读取的列表中只包含索引列的记录，这种情况下不会进行回表</p><h3 id="7-5-6-让索引列以列名的形式在搜索条件中单独出现"><a href="#7-5-6-让索引列以列名的形式在搜索条件中单独出现" class="headerlink" title="7.5.6 让索引列以列名的形式在搜索条件中单独出现"></a>7.5.6 让索引列以列名的形式在搜索条件中单独出现</h3><p>不要将索引列合并成为一个表达式，会导致不能形成合适的扫描区间</p><p><code>SELECT * FROM single_table WHERE key2 * 2 &lt; 4</code>这种格式不行</p><p>换成</p><p><code>SELECT * FROM single_table WHERE key2 &lt; 4/2</code></p><h3 id="7-5-7-新插入记录是主键大小对效率的影响"><a href="#7-5-7-新插入记录是主键大小对效率的影响" class="headerlink" title="7.5.7 新插入记录是主键大小对效率的影响"></a>7.5.7 新插入记录是主键大小对效率的影响</h3><p>最好让主键的列具有AUTO_INCREMENT属性的递增主键</p><p>避免主键索引在创建的时候进行页面分裂，造成更大的性能消耗</p><h3 id="7-5-8-冗余和重复索引"><a href="#7-5-8-冗余和重复索引" class="headerlink" title="7.5.8 冗余和重复索引"></a>7.5.8 冗余和重复索引</h3><p>如果建立联合索引，对于其中第一个字段建立新的索引是冗余的，这冗余的索引尽量避免</p><h3 id="感悟：索引的最左匹配原则"><a href="#感悟：索引的最左匹配原则" class="headerlink" title="感悟：索引的最左匹配原则"></a>感悟：索引的最左匹配原则</h3><p>学习后对于索引的最左匹配原则有了一些理解，最左匹配原则分为两个</p><ol><li>联合索引中，使用根据构建联合索引的数据列顺序；在查询的时候可以使用索引的靠左的数据列进行查询，能够有效的使用索引加速查询；</li><li>在字符串匹配中，LIKE “str%”类型的查询条件，可以利用索引优化查询速度。</li></ol><p>原理总结起来就是一句话：</p><ul><li>索引能够优化的查询，是查询条件满足在索引记录中连续分布的条件记录</li></ul><p>联合索引中的最左匹配原则，例如使用这样一个索引</p><p><code>ALTER TABLE single_table ADD INDEX idx_a_b_c (a, b, c)</code></p><p>索引数据页中，首先是根据a字段排序B+树，然后是在相同的a字段下排序b字段</p><p>如果查询的条件是，<code>WHERE a &gt; 1 AND b &lt; 100;</code></p><p>首先会使用a字段，获取到的索引的扫描区间是（1， +∞）</p><p>因为idx_a_b_c索引首先是使用a排序的，所以这个扫描区间对于idx_a_b_c是连续可用的，能够使用索引优化查询</p><p>之后的b字段，因为之前的扫描区间已经满足了a字段，所以之后b只用在子区间之中进行查找，在相同的a字段中，满足b条件的扫描区间也是连续的，同样能够优化查询</p><p>对于字符串类似，使用相同字符开头的字符串在索引页中是连续的，能够使用优化查询速度</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树索引 -《MySQL是怎样运行的》ch6</title>
      <link href="/2022/08/07/2022-08-07%20B-%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/08/07/2022-08-07%20B-%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CH6-快速查询的秘籍——B-树索引"><a href="#CH6-快速查询的秘籍——B-树索引" class="headerlink" title="CH6 快速查询的秘籍——B+树索引"></a>CH6 快速查询的秘籍——B+树索引</h1><h2 id="6-1-没有索引进行查找"><a href="#6-1-没有索引进行查找" class="headerlink" title="6.1  没有索引进行查找"></a>6.1  没有索引进行查找</h2><p>假设有一个查询语句</p><p><code>SELECT [查询列表] FROM 表名 WHERE 列名 = xxx</code></p><h3 id="6-1-1-在一个页中查找"><a href="#6-1-1-在一个页中查找" class="headerlink" title="6.1.1 在一个页中查找"></a>6.1.1 在一个页中查找</h3><p>假设表中的数据比较少，所有记录可以存放到一个页中去。如果没有索引，根据条件的不同，有两种查询方式</p><ul><li>以主键为搜索条件：在页目录中使用二分法定位到对应的槽，然后遍历该槽的分组中的记录</li><li>以其他列作为搜索条件：只能从Infimum记录开始遍历单向链表中的记录，比对条件，效率较低</li></ul><h3 id="6-1-2-在多个页中查找"><a href="#6-1-2-在多个页中查找" class="headerlink" title="6.1.2 在多个页中查找"></a>6.1.2 在多个页中查找</h3><p>如果数据量较大，一个页中无法定位到，需要用好多页进行记录存储，则查找分为两个步骤：</p><ul><li>定位到记录所在的页</li><li>从所在的页内查找到相应的记录</li></ul><h2 id="6-2-索引"><a href="#6-2-索引" class="headerlink" title="6.2 索引"></a>6.2 索引</h2><p>之前的两种方式检索效率太低，索引被引入完成高效搜索</p><h3 id="6-2-1-一个简单的索引方案"><a href="#6-2-1-一个简单的索引方案" class="headerlink" title="6.2.1 一个简单的索引方案"></a>6.2.1 一个简单的索引方案</h3><p>略</p><h3 id="6-2-2-InnoDB中的索引方案"><a href="#6-2-2-InnoDB中的索引方案" class="headerlink" title="6.2.2 InnoDB中的索引方案"></a>6.2.2 InnoDB中的索引方案</h3><p>制作目录项在一个连续物理存储器上，使用主键值进行查找，使用二分法迅速定位具体的目录项，存在问题</p><ul><li>当表记录非常多的时候，需要非常大的存储空间才能放下所有目录项</li><li>增删改导致牵一发而动全身</li></ul><p>InnoDB中使用了存储用户记录的数据页存储目录项，通过修改头信息中的record_type属性，其取值代表意思如下</p><ul><li>0：普通用户记录</li><li>1：目录项记录</li><li>2：Infimum记录</li><li>3：Supremum记录</li></ul><p><img src="/xkond/2022/08/07/2022-08-07%20B-%E6%A0%91%E7%B4%A2%E5%BC%95/image-20220807211517681-9878121.png" alt="image-20220807211517681"></p><p>目录项记录页和用户记录的不同点</p><ul><li>目录项记录的record_type值是1，普通用户记录的record_type值是1</li><li>目录项记录只有主键值和页的编号两个类，普通用户列可以是自定义的，同时还有很多列，另外还有InnoDB自己的隐藏列</li><li>头信息的min_rec_flag属性，只有目录项记录属性才有可能为1</li></ul><p>根据主键值查找的步骤可以拆分为</p><ol><li>找到存储目录项记录的页，通过二分法快速定位到对应的项记录</li><li>在用户记录的页中根据二分法快速定位到主键值的记录</li></ol><p>遇到一个问题，如果表中的数据非常多，会存在很多存储目录项记录的页，如何快速定位？</p><p>答：使用更高级的索引，像是多级目录一样，大目录套小目录，最后的节点才是存储用户数据；这种数据结构被称为B+树</p><p><img src="/xkond/2022/08/07/2022-08-07%20B-%E6%A0%91%E7%B4%A2%E5%BC%95/image-20220807211921693.png" alt="image-20220807211921693"></p><p>B+树的节点：存放目录项记录的数据页</p><p>B+树叶节点：最底层的节点，存储真正的用户数据</p><p>B+树根节点：最顶层的节点</p><blockquote><p>树节点能够存储的数据量是指数级别增加的，索引一般情况下用到的树节点不会超过4层</p><p>page Header中有一个PAGE_LEVEL参数代表数据页节点在B+树中的层级</p></blockquote><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p>之前的索引有两个特点</p><ol><li>使用记录主键值的大小进行记录和页的排序，包含三层含义<ul><li>页内按照主键的大小顺序排成一个单向链表被划分为若干组，每个组中主键值最大的记录在页内的偏移量会被当做槽依次存放在页目录中</li><li>各个存放用户记录的页也是根据页中用户记录的主键排列成为一个双向链表</li><li>存放目录项记录的页分为不同的层级，在同一层级中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表</li></ul></li><li>B+树的叶子节点存储了完整的用户记录。所谓用户记录，就是值这个记录中存储了所有列的值</li></ol><p>具有这两个特点的B+树称为聚簇索引，这种聚簇缩影不需要显式创建，InnoDB存储引擎会自动为我们创建索引，聚簇索引就是数据的存储方式，就是所谓的“索引即数据，数据即索引”</p><h4 id="2-二级索引"><a href="#2-二级索引" class="headerlink" title="2. 二级索引"></a>2. 二级索引</h4><p>聚簇索引只有在搜索条件是主键值的时候才能发挥作用，原因是B+树中的数据都是按照主键进行排序的</p><p>如果想要以别的列作为搜索条件，可以新建B+树，采用不同的排序规则</p><p><img src="/xkond/2022/08/07/2022-08-07%20B-%E6%A0%91%E7%B4%A2%E5%BC%95/image-20220807215809594-9880693.png" alt="image-20220807215809594"></p><p>这个B+树和之间的聚簇索引有几处不同</p><ol><li>使用记录c2列的大小进行记录和页的排序<ul><li>页内的就是按照c2列的大小排列成单向链表，页内的记录被划分成若干组，每个组中c2列值最大的记录在页内的偏移量会被记录</li><li>存放用户记录的页也是根据页中记录c2列大小顺序排列成一个双向链表</li><li>存放目录项记录的业数据分为不同层级，一个层级中的页也是根据页中目录项记录c2列大小排列成为双向链表</li></ul></li><li>B+树的叶子节点不是完整用户数据，只有c2列和主键两个列的值</li><li>目录项记录不再是主键+页号的搭配，而是c2列+页号的搭配</li></ol><p>这样一次使用c2列的完整查找如下</p><blockquote><ol><li>通过二分法确定第一条满足的目录项记录所在的页</li><li>通过目录项记录所在页面查找第一条符合条件的用户数据所在列</li><li>找到存储的用户记录页中找到具体的数据</li><li>这颗树值存储了c2数据和主键的值，所以要查找完整数据，需要根据主键数据在聚簇索引中查找到完整的用户数据；之后回到叶子节点处，找到下一个满足条件的用户数据，直到下一条记录不满足条件为止</li></ol><p>这个回到聚簇索引查找完整数据的过程被称为回表</p><p>数据不存储在每个B+树索引的原因是因为太浪费存储空间了</p></blockquote><p>这种B+树索引又被称为二级索引或者辅助索引</p><h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引"></a>3. 联合索引</h4><p>如果同时以多个列的大小作为排序规则，同时为多个列建立索引，排序规则是这样的，以c2和c3列为例</p><ul><li>先把各个记录和页按照c2列的值进行排序</li><li>在记录的c2列相同的情况下，再采用c3列进行排序</li></ul><p><img src="/xkond/2022/08/07/2022-08-07%20B-%E6%A0%91%E7%B4%A2%E5%BC%95/image-20220807222047317-9882050.png" alt="image-20220807222047317"></p><p>B+树叶子节点的用户记录是由c2列、c3列和主键c1列构成的</p><h3 id="6-2-3-InnoDB中B-树的注意事项"><a href="#6-2-3-InnoDB中B-树的注意事项" class="headerlink" title="6.2.3 InnoDB中B+树的注意事项"></a>6.2.3 InnoDB中B+树的注意事项</h3><h4 id="1-根页面不变"><a href="#1-根页面不变" class="headerlink" title="1. 根页面不变"></a>1. 根页面不变</h4><p>创建B+树的过程是这样的</p><ol><li>为表创建一个B+树索引的时候，都会为这个索引创建一个根节点页面，最开始这个页面是空的</li><li>插入用户记录时，先把用户记录存储到这个根节点中</li><li>在根节点可用空间用完之后，将根节点中的记录复制到一个新分配的页中，然后对新页进行分离操作，此时根节点升级为存储目录页，将新的页的目录项记录插入根节点中去</li></ol><p>B+树的根节点自创建之后变不会再移动。其页号记录在一个指定地方，但凡之后每次用到这个索引的时候都会通过指定的页号访问索引</p><h4 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h4><p>如果目录项记录只有一个索引列+页号的搭配，那么如果插入对应的索引列值相同，应该放到哪一个页中？</p><p>答：实际上节点内存储一个记录，唯一确定是由索引列值+主键列值+页号构成</p><p>最后一定能够定位到唯一的一条目录项记录</p><blockquote><p>二级索引可以看做(c2，c1(主键))的联合索引</p></blockquote><h4 id="3-一个页面至少容纳2条数据"><a href="#3-一个页面至少容纳2条数据" class="headerlink" title="3. 一个页面至少容纳2条数据"></a>3. 一个页面至少容纳2条数据</h4><p>略</p><h3 id="6-2-4-MyISAM索引方案"><a href="#6-2-4-MyISAM索引方案" class="headerlink" title="6.2.4 MyISAM索引方案"></a>6.2.4 MyISAM索引方案</h3><p>使用树形结构存储索引，但是索引和数据是分开存储的</p><p>同时插入数据没有可以按照主键大小进行排序，存储数据时按照插入顺序进行存储的，通过行号访问数据，对于索引每次都至少进行一次回表操作</p><blockquote><p>可以理解为索引索引都是二级索引</p><p>“索引即索引，数据即数据”</p></blockquote><h3 id="6-2-5-MySQL创建和删除索引语句"><a href="#6-2-5-MySQL创建和删除索引语句" class="headerlink" title="6.2.5 MySQL创建和删除索引语句"></a>6.2.5 MySQL创建和删除索引语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表同时创建单个列的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">  列信息 ...,</span><br><span class="line">  (KEY<span class="operator">|</span>INDEX) 索引名 (被索引的单个列或者多个列)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构添加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> (INDEX<span class="operator">|</span>KEY) 索引名 (被索引的单个列或者多个列);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> (INDEX<span class="operator">|</span>KEY) 索引名;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB数据页结构 -《MySQL是怎样运行的》ch5</title>
      <link href="/2022/08/01/2022-08-01%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/01/2022-08-01%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="CH5-InnoDB数据页结构"><a href="#CH5-InnoDB数据页结构" class="headerlink" title="CH5 InnoDB数据页结构"></a>CH5 InnoDB数据页结构</h1><h2 id="5-1-不同类型页简介"><a href="#5-1-不同类型页简介" class="headerlink" title="5.1 不同类型页简介"></a>5.1 不同类型页简介</h2><p>页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB</p><p>InnDB为了不同目的设计了多重不同类型的页，例如</p><ul><li><p>存放表空间头部信息的页</p></li><li><p>存放Change Buffer信息的页</p></li><li><p>存放INODE的页</p></li><li><p>存放undo日志信息的页</p></li><li><p>存放表中记录的页称为索引（INDEX）页，也称为数据页</p></li></ul><h2 id="5-2-数据页结构速览"><a href="#5-2-数据页结构速览" class="headerlink" title="5.2 数据页结构速览"></a>5.2 数据页结构速览</h2><p>一个数据页根据功能不同可以进行划分如下：</p><img src="image-20220801110405513-9323050.png" alt="image-20220801110405513" style="zoom: 33%;" /><p>可以看出来，一个InnoDB数据页的存储空间大致划分为7个部分，有的部分大小确定，有的则是不确定的</p><h2 id="5-3-记录在页中的存储"><a href="#5-3-记录在页中的存储" class="headerlink" title="5.3 记录在页中的存储"></a>5.3 记录在页中的存储</h2><p>数据记录存储的流程</p><ul><li>新生成的页没有User Records空间</li><li>每次插入数据，去Free Space申请一个新空间，划分到User Records部分</li><li>Free Space被全部用完后，意味着这个页使用完了，需要去申请新的页</li></ul><h3 id="5-3-1-记录头信息的秘密"><a href="#5-3-1-记录头信息的秘密" class="headerlink" title="5.3.1 记录头信息的秘密"></a>5.3.1 记录头信息的秘密</h3><p>创建一个表，表格中的格式示意图如同：</p><img src="image-20220801142324266.png" alt="image-20220801142324266" style="zoom:33%;" /><p>创建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `page_demo` (</span><br><span class="line">  `c1` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c2` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c3` <span class="type">varchar</span>(<span class="number">10000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`c1`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT</span><br></pre></td></tr></table></figure><p>插入几条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果只展示其中的的头信息以及c1, c2, c3列值的信息，将数据这样展示，理解其中头信息的属性的作用</p><p><img src="/xkond/2022/08/01/2022-08-01%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20220801143009164-9335412.png" alt="image-20220801143009164"></p><ul><li><p>deleted_flag：该属性用来标记当前记录是否被删除，占用1比特，值为0表示记录存在，值为1表示记录删除</p><blockquote><p>操作删除的记录实际没有从磁盘中被删除，因为删除之后，需要在磁盘上重现排列，造成性能消耗</p><p>所有删除掉的记录被组成为一个垃圾链表，记录在链表中的空间称为可重用空间</p></blockquote></li><li><p>min_rec_flag：B+树中每层叶子节点中的最小的目录项记录都会添加该标记</p></li><li><p>n_owned：略</p></li><li><p>heap_no：我们向表中插入的记录的本质上都是放到数据页的User Records部分，一条条数据紧密的排列称为堆，堆中的相对位置就是heap_no。</p><blockquote><p>heap_no值为0 和1 的记录被自动在每个页中加入了，这两条记录被称为伪记录或者虚拟记录，在堆中的位置相对靠前</p><p>一条代表页面中的最小记录，称为Infimum记录</p><p>另外一条代表页面中的最大记录，称为Supremum记录</p></blockquote><blockquote><p>堆中记录的heap_no在被分配后不会发生改动了，即使删除了记录</p></blockquote></li><li><p>Record_type：属性代表当前记录的类型。一共四种类型的记录，0表示普通记录，1表示B+树非叶节点的目录项记录，2表示Infimum记录，3表示Supremum记录。</p></li><li><p>next_record：表示当前记录的真实数据到下一条记录的真实数据的距离；如果属性为正，代表下一条记录在当前记录后；属性记录为负，代表下一条记录在当前记录前面（本质链表）</p><blockquote><p>注意，下一条记录是的不是插入顺序的下一条</p><p>而是按照主键值从下到大排列的下一条</p></blockquote></li></ul><p><strong>补充</strong>：使用当前记录的真实数据到下一条记录的真实数据的距离，因为这个位置非常好，向左就是头信息，向右就是真实数据</p><h2 id="5-4-Page-Directory（页目录）"><a href="#5-4-Page-Directory（页目录）" class="headerlink" title="5.4 Page Directory（页目录）"></a>5.4 Page Directory（页目录）</h2><p>如果查找数据需要从头开始查找，性能会较低，所以设计MySQL的时候设计了一个目录，制作过程如下：</p><ol><li>将所有的正常记录（包括Infimum和Supremum，不包括来及链表的记录）划分为几个组；</li><li>每个组的最后一条记录（最大记录），记录的头信息中的n_owned属性表示该组内共有几条数据；</li><li>每个组中的最后一条记录在页面中的地址偏移量（该记录的真实数据与页面第0个字节的距离），被单独提取出来保存到页尾部的地方。这个地方就是Page Directory（页目录）。页目录中的地址偏移量称为槽</li></ol><p>一些规定：</p><blockquote><p>Infimum分组只能有一条记录</p><p>Supremum分组只能在1~8条之间</p><p>其他分组条数范围在4~8之间</p></blockquote><p>给记录分组，是按照下面的步骤进行的</p><ol><li>初始情况下，一个数据页只有Infimum和Supremum记录这两个，分属于连个槽，分别代表Infimum和Supremum记录在页面中的地址偏移量</li><li>之后每插入一条记录，都会从页目录中找到对应记录的主键值比待插入记录的主键值大并且差值最小的槽，然后该槽对应的记录的n_owner加1，表示本组内又添加一个记录，知道该组的记录等于8个</li><li>当一个组中的记录等于8后，再插入一条记录，会将组中的记录拆分为两个组，其中一个组中四条记录，另一个5条记录。拆分过程在页目录中添加一个新的槽</li></ol><p>槽和数据记录的关系图</p><p><img src="/xkond/2022/08/01/2022-08-01%20InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20220801154139931-9339703.png" alt="image-20220801154139931"></p><p>在一个数据页中查找指定主键值得记录，过程分为两步：</p><ol><li>通过二分法确定该记录所在分组对应的槽，然后找到该槽所在分组中主键值最小的记录</li><li>通过next_record属性遍历查找该槽中的各个记录</li></ol><h2 id="5-5-Page-Header（页面头部）"><a href="#5-5-Page-Header（页面头部）" class="headerlink" title="5.5 Page Header（页面头部）"></a>5.5 Page Header（页面头部）</h2><p>页头部是用于记录数据页中的记录的状态信息，占用固定的56字节，用途如下</p><table><thead><tr><th>状态名称</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>未使用的空间的最小地址，该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>第一位表示本记录是否是紧凑型的记录，剩余15位表示本页对中记录的数量</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>各个已删除的记录通过next_record组成一个单向链表，表示该链表头结点在页中的偏移量</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除的记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中用户记录的数量（不包括Infimum和Supremum，被删除的数据）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前也的最大事务id</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子节点段的头部信息</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子节点端的头部信息</td></tr></tbody></table><h2 id="5-6-File-Header（文件头部）"><a href="#5-6-File-Header（文件头部）" class="headerlink" title="5.6 File Header（文件头部）"></a>5.6 File Header（文件头部）</h2><p>File用于存储数据页的各种状态信息</p><p>包含以下状态</p><table><thead><tr><th>状态名称</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>属性表示该页的校验和，在高于4.0.14的版本中</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8字节</td><td>页面被最后修改时对应的LSN（Log Sequence Number，日志序列号）值</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8字节</td><td>仅仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪一个表空间</td></tr></tbody></table><ul><li>FIL_PAGE_SPACE_OR_CHKSUM：该属性代表当前页面的校验和，校验和是将长字符串生成短的值，比较短的值河科院省去长字符串的时间损耗</li><li>FIL_PAGE_OFFSET：每一个页的页号，通过页号唯一定位一个页</li><li>FIL_PAGE_TYP：页的类型，具体略</li><li>FIL_PAGE_PREV &amp;&amp; FIL_PAGE_NEXT：无法通过一个页分配数据，将数据分配到多个不连续的表中存储，该属性用于关联数据页的表</li></ul><h2 id="5-7-File-Trailer（文件尾部）"><a href="#5-7-File-Trailer（文件尾部）" class="headerlink" title="5.7 File Trailer（文件尾部）"></a>5.7 File Trailer（文件尾部）</h2><p>用于监测一个页是否完整</p><blockquote><p>应对场景：</p><p>在内存中修改了数据，刷新到磁盘时候断电了，只刷新了一部分的数据</p></blockquote><p>该部分由8个字节组成，分为两个部分</p><ul><li>前四个字节代表也的校验和。发生刷新的时候，首先刷新页首File Header的校验和，写完后更新页尾的校验和，如果二者不同，代表刷新过程中发生了错误</li><li>后4个字节代表最后修改的LSN的后4个字节，同样用于和页首比对，如果二者不同，代表刷新过程中发生了错误</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB引擎存储 - 《MySQL是怎样运行的》ch4</title>
      <link href="/2022/07/24/2022-07-24%20InnoDB%E5%BC%95%E6%93%8E%E5%AD%98%E5%82%A8/"/>
      <url>/2022/07/24/2022-07-24%20InnoDB%E5%BC%95%E6%93%8E%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch4-InnoDB记录存储结构"><a href="#Ch4-InnoDB记录存储结构" class="headerlink" title="Ch4 InnoDB记录存储结构"></a>Ch4 InnoDB记录存储结构</h1><h2 id="4-2-InnoDB页简介"><a href="#4-2-InnoDB页简介" class="headerlink" title="4.2 InnoDB页简介"></a>4.2 InnoDB页简介</h2><p>InnoDB是将表格中存储到磁盘上的存储引擎</p><p>什么是页：</p><blockquote><p>数据存储在磁盘中</p><p>真正处理数据在内存中</p><p>需要读写磁盘到内存中，如果一条条记录读写会非常慢</p><p>解决方案是将数据划分为若干个页，以也作为磁盘和内存之间交互的单位</p><p>InnoDB中页的大小一般为16KB，就是一次最少可以从磁盘中读取16KB到内存中去</p><p>系统变量<code>innodb_page_size</code>表明了InnoDB存储引擎中的页大小，该变量只能在初始化数据目录时候指定</p></blockquote><h2 id="4-3-InnoDB行格式"><a href="#4-3-InnoDB行格式" class="headerlink" title="4.3 InnoDB行格式"></a>4.3 InnoDB行格式</h2><p>插入数据通常是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式被称为行格式或者记录格式</p><p>目前设计InnoDB有四种不同类型的行格式</p><ul><li>COMPACT</li><li>REDUNDANT</li><li>DYNAMIC</li><li>COMPRESSED</li></ul><h3 id="4-3-1-指定行格式的语法"><a href="#4-3-1-指定行格式的语法" class="headerlink" title="4.3.1 指定行格式的语法"></a>4.3.1 指定行格式的语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建或修改表的时候指定记录使用的行格式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列信息) ROW_FORMAT<span class="operator">=</span>行格式</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ROW_FORMAT<span class="operator">=</span>行格式</span><br></pre></td></tr></table></figure><h3 id="4-3-2-COMPACT行格式"><a href="#4-3-2-COMPACT行格式" class="headerlink" title="4.3.2 COMPACT行格式"></a>4.3.2 COMPACT行格式</h3><p><img src="/xkond/2022/07/24/2022-07-24%20InnoDB%E5%BC%95%E6%93%8E%E5%AD%98%E5%82%A8/image-20220724143621846-8644589.png" alt="image-20220724143621846"></p><h3 id="4-3-3-REDUNDANT行格式"><a href="#4-3-3-REDUNDANT行格式" class="headerlink" title="4.3.3 REDUNDANT行格式"></a>4.3.3 REDUNDANT行格式</h3><p><img src="/xkond/2022/07/24/2022-07-24%20InnoDB%E5%BC%95%E6%93%8E%E5%AD%98%E5%82%A8/image-20220724145423316-8645667.png" alt="image-20220724145423316"></p><h3 id="4-3-4-DYNAMIC和COMPRESSED行格式"><a href="#4-3-4-DYNAMIC和COMPRESSED行格式" class="headerlink" title="4.3.4 DYNAMIC和COMPRESSED行格式"></a>4.3.4 DYNAMIC和COMPRESSED行格式</h3><p>类似于COMPACT，处理溢出列数据方式不同</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL字符集 -《MySQL是怎样运行的》ch3</title>
      <link href="/2022/07/23/2022-07-23%20MySQL%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
      <url>/2022/07/23/2022-07-23%20MySQL%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch3-字符集和比较规则"><a href="#Ch3-字符集和比较规则" class="headerlink" title="Ch3 字符集和比较规则"></a>Ch3 字符集和比较规则</h1><h2 id="3-1-字符集和比较规则简介"><a href="#3-1-字符集和比较规则简介" class="headerlink" title="3.1 字符集和比较规则简介"></a>3.1 字符集和比较规则简介</h2><h3 id="3-1-1-字符集简介"><a href="#3-1-1-字符集简介" class="headerlink" title="3.1.1 字符集简介"></a>3.1.1 字符集简介</h3><p>字符集是字符与二进制数据的映射关系，两个关键点</p><ol><li>界定字符范围：哪些字符需要被映射成二进制数据；</li><li>编码规则：如何将字符映射成二进制数据，称为编码；将二进制数据映射称为字符称为解码。</li></ol><h3 id="3-1-2-比较规则简介"><a href="#3-1-2-比较规则简介" class="headerlink" title="3.1.2 比较规则简介"></a>3.1.2 比较规则简介</h3><p>比较字符集的大小规则称为比较规则，常见的比较规则</p><ul><li>将两个大小写不同的字符全部转为大写或小写</li><li>在比较两个字符对应的二进制数据</li></ul><h3 id="3-1-3-一些重要的字符集"><a href="#3-1-3-一些重要的字符集" class="headerlink" title="3.1.3 一些重要的字符集"></a>3.1.3 一些重要的字符集</h3><p>常用的字符集情况</p><ul><li><p>ASCII字符集：128个字符（不含汉字）</p></li><li><p>ISO 8859-1 字符集：256字符（不含汉字）</p></li><li><p>GB2312字符（含汉字）：收录汉字6763个，其他文字符号682个。字符集兼容ASCII字符集</p></li><li><p>GBK字符集：对于GB2312字符集进行了扩充</p></li><li><p>UTF-8 字符集：几乎收录了当前所有世界国家的字符集，兼容ASCII字符集</p></li></ul><h2 id="3-2-MySQL支持的字符集和比较规则"><a href="#3-2-MySQL支持的字符集和比较规则" class="headerlink" title="3.2 MySQL支持的字符集和比较规则"></a>3.2 MySQL支持的字符集和比较规则</h2><h3 id="3-2-1-MySQL中的utf-8和utf8mb4"><a href="#3-2-1-MySQL中的utf-8和utf8mb4" class="headerlink" title="3.2.1 MySQL中的utf-8和utf8mb4"></a>3.2.1 MySQL中的utf-8和utf8mb4</h3><p>MySQL中，utf8是utf8mb3的别名</p><ul><li>utf8mb3：“阉割”过的UTF-8字符集，只使用1~3个字节表示字符</li><li>utf8mb4：真正utf-8字符集，使用1~4个字节表示字符</li></ul><p>如果需要存储一些emoji表情，使用utf8mb4</p><h3 id="3-2-2-字符集的查看"><a href="#3-2-2-字符集的查看" class="headerlink" title="3.2.2 字符集的查看"></a>3.2.2 字符集的查看</h3><p>使用以下命令，查看支持的字符集</p><p><code>SHOW (CHARACTER SET|CHARSET) [LIKE 匹配模式]</code></p><h3 id="3-2-3-比较规则的查看"><a href="#3-2-3-比较规则的查看" class="headerlink" title="3.2.3 比较规则的查看"></a>3.2.3 比较规则的查看</h3><p>以下命令查看MySQL支持的比较规则</p><p><code>SHOW COLLATION [LIKE 匹配模式]</code></p><p>比较规则的特点</p><ul><li>比较规则是以与其关联的字符集的名称开头。</li><li>后面紧跟该比较规则应用的语言</li><li>名称后缀为该比较规则是否区分语言中的重音、大小写</li></ul><h3 id="3-3-字符集和比较规则的应用"><a href="#3-3-字符集和比较规则的应用" class="headerlink" title="3.3 字符集和比较规则的应用"></a>3.3 字符集和比较规则的应用</h3><h3 id="3-3-1-个级别的字符集和比较规则"><a href="#3-3-1-个级别的字符集和比较规则" class="headerlink" title="3.3.1 个级别的字符集和比较规则"></a>3.3.1 个级别的字符集和比较规则</h3><ol><li><p>服务器级别<br>通过系统变量设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gb2312</span><br><span class="line">collation_server=gb2312_chinese_ci</span><br></pre></td></tr></table></figure></li><li><p>数据库级别<br>通过创建数据库或者修改数据库指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名</span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集名称]</span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> 比较规则名称]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看字符集和比较规则</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;collation_database&quot;;</span><br></pre></td></tr></table></figure></li><li><p>表级别</p><p>通过创建表和修改表格指定字符集和比较规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列信息)</span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集名称]</span><br><span class="line">[<span class="keyword">COLLATE</span> 比较规则名称]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 (列信息)</span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集名称]</span><br><span class="line">[<span class="keyword">COLLATE</span> 比较规则名称]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看字符集和比较规则</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;collation_database&quot;;</span><br></pre></td></tr></table></figure></li><li><p>列级别</p><p>在创建和修改列的时候指定列的字符集和比较规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">列明 字符串类型 [<span class="type">CHARACTER</span> SEET 字符集名称] [<span class="keyword">COLLATE</span> 比较规则名称]，</span><br><span class="line">  其他列</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 列名 字符串类型 [<span class="type">CHARACTER</span> SEET 字符集名称] [<span class="keyword">COLLATE</span> 比较规则名称];</span><br></pre></td></tr></table></figure></li></ol><p><strong>只修改字符集或者比较规则</strong></p><ul><li>只修改字符集，比较规则变为修改后的字符集的默认比较规则</li><li>只修改比较规则，则字符集变为修改后的比较规则对应的字符集</li></ul><p><strong>各个级别字符集和比较规则之间关联</strong></p><ul><li>创建或修改列是没有显式指定字符集和比较规则，该列默认应用表的字符集和比较规则</li><li>表未指定默认使用数据库级别</li><li>数据库未指定默认使用服务器级别</li></ul><h3 id="3-3-2-客户端和服务器通信过程中使用的字符集"><a href="#3-3-2-客户端和服务器通信过程中使用的字符集" class="headerlink" title="3.3.2 客户端和服务器通信过程中使用的字符集"></a>3.3.2 客户端和服务器通信过程中使用的字符集</h3><ol><li><p>编码和解码使用的字符集不一致</p><p>对于同一个字符串，如果编码和解码时候使用的字符集不一样，会导致意外的错误，看起来像是产生了乱码</p></li><li><p>字符集转换</p><p>接收到一个字符串，按照原有的字符集进行解码，再使用新的字符集编码；该过程称为字符集转换</p></li></ol><p><strong>MySQL中的字符集转换过程</strong></p><ul><li><p>客户端发送请求</p><p>客户端发送请求遵循了一定的MySQL通信协议</p><p>一般情况下，客户端编码请求字符串时候使用的字符集与操作系统当前使用的字符集一致</p></li><li><p>服务器接受请求</p><p>本质上，服务器接收到的是一个字节序列。</p><p>服务器将这个字节序列看做是使用系统变量<code>character_set_client</code>代表的字符集进行编码的字节序列（这个变量在建立连接后，是服务器单独为客户端维护的SESSION级别的）</p><p>设置错误的<code>character_set_client</code>导致错误，展现乱码</p></li><li><p>服务器处理请求</p><p>服务器根据客户端的字符集类型<code>character_set_client</code>进行进行字符集转换识别</p><p>之后通过SESSION级别的系统变量<code>character_set_connection</code>对应的字符集进行编码</p><p>还有一个与之匹配的SESSION级别的系统变量<code>collation_connection</code>表示字符串对应的比较规则</p></li><li><p>服务器生成响应</p><p>SESSION级别的系统变量<code>character_set_result</code>指定了服务器返回客户端的响应中，字符串对应的编码</p></li><li><p>客户端接收到响应</p><p>客户端接收请求，根据客户端的字符接解释该字节序列</p></li></ul><p>服务器的三个系统变量：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td><code>character_set_client</code></td><td>服务器认为客户端的请求是字符集，进行解码</td></tr><tr><td><code>character_set_connection</code></td><td>服务器处理请求时，将请求序列按照该字符集进行编码</td></tr><tr><td><code>character_set_result</code></td><td>服务器使用该字符集对返回客户端的字符串进行编码</td></tr></tbody></table><p>在连接服务器时，客户端将默认的字符集信息与用户名、密码一起发送给服务器，服务器根据系统变量默认值初始化客户端的默认字符集</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识MySQL - 《MySQL是怎样运行的》ch1 - ch2</title>
      <link href="/2022/07/17/2022-07-17%20%E5%88%9D%E8%AF%86MySQL/"/>
      <url>/2022/07/17/2022-07-17%20%E5%88%9D%E8%AF%86MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch1-初识MySQL"><a href="#Ch1-初识MySQL" class="headerlink" title="Ch1 初识MySQL"></a>Ch1 初识MySQL</h1><h2 id="1-1-MySQL的客户端-x2F-服务器架构"><a href="#1-1-MySQL的客户端-x2F-服务器架构" class="headerlink" title="1.1 MySQL的客户端&#x2F;服务器架构"></a>1.1 MySQL的客户端&#x2F;服务器架构</h2><p>服务端程序直接与存储的数据打交道，多个客户端程序连接到服务器程序，向服务器发送增删改查的请求，服务器程序根据请求对于数据进行处理</p><p>客户端程序使用用户名和密码登录服务器，只有在登录之后才能向服务器发送请求操作数据</p><blockquote><p>使用场景：</p><ol><li>启动MySQL服务器程序</li><li>启动MySQL客户端程序，连接到服务器程序</li><li>在客户端程序中输入命令，将其作为请求发送给服务器程序；</li><li>服务器程序在收到请求后，根据请求查询具体数据，随后结果返回客户端</li></ol></blockquote><p>代表MySQL服务器程序的进程称为MySQL数据库实例</p><h2 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装"></a>1.2 MySQL的安装</h2><p><strong>注意：安装MySQL一定要记住安装目录</strong></p><blockquote><p>常见安装目录</p><ul><li>macOS操作系统下： &#x2F;usr&#x2F;local&#x2F;mysql</li><li>Windows操作系统下：C:\Program Files\MySQL\MySQL Server 5.7\</li></ul></blockquote><h3 id="1-2-1-配置bin目录下的可执行文件"><a href="#1-2-1-配置bin目录下的可执行文件" class="headerlink" title="1.2.1 配置bin目录下的可执行文件"></a>1.2.1 配置bin目录下的可执行文件</h3><p>执行可执行文件</p><ul><li><p>使用路径执行<br><code>./bin/mysqld</code></p></li><li><p>添加bin目录的绝对路径到环境变量的PATH中去</p><blockquote><p>目前使用brew安装mysql，则可以在.zshrc中添加以下一行</p><p><code>export PATH=&quot;/opt/homebrew/Cellar/mysql@5.7/5.7.38/bin:$PATH&quot;</code></p><p>之后重启<code>source .zshrc</code></p></blockquote></li></ul><h2 id="1-3-启动MySQL服务器程序"><a href="#1-3-启动MySQL服务器程序" class="headerlink" title="1.3 启动MySQL服务器程序"></a>1.3 启动MySQL服务器程序</h2><h3 id="1-3-1-在类UNIX系统中启动"><a href="#1-3-1-在类UNIX系统中启动" class="headerlink" title="1.3.1 在类UNIX系统中启动"></a>1.3.1 在类UNIX系统中启动</h3><ol><li><p>mysqld<br>作用：直接启动一个MySQL服务器进程<br>使用场景：一般不常用</p></li><li><p>mysqld_safe<br>作用：一个启动脚本，间接调用mysqld并监控运行状态了；当服务器进程出现错误时，帮助重启服务器程序；同时将服务器程序的出错信息和其他诊断信息输出到错误日志（默认是一个一.err为拓展名的文件中去）</p><p>使用场景：&#x2F;&#x2F; TODO</p></li><li><p>mysql.server<br>作用：一个启动脚本，间接调用mysql_safe。添加参数控制启动和关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start  <span class="comment"># 启动服务器程序</span></span><br><span class="line">mysql.server stop   <span class="comment"># 关闭服务器程序</span></span><br></pre></td></tr></table></figure><p>使用场景：通常使用<br>注意：有可能需要手动安装mysql.server脚本</p></li><li><p>mysqld_multi<br>作用： 运行多个MySQL服务器进程，启动或停止多个服务器进程，报告其运行状态</p></li></ol><h3 id="1-3-2-在Windows系统中启动"><a href="#1-3-2-在Windows系统中启动" class="headerlink" title="1.3.2 在Windows系统中启动"></a>1.3.2 在Windows系统中启动</h3><p>相对简单，略</p><ol><li><p>手动启动</p></li><li><p>服务方式启动</p></li></ol><h2 id="1-4启动MySQL客户端程序"><a href="#1-4启动MySQL客户端程序" class="headerlink" title="1.4启动MySQL客户端程序"></a>1.4启动MySQL客户端程序</h2><p>建立连接</p><p><code>mysql -h主机名 -u用户名 -p密码</code></p><p>关闭客户端，输入以下任意命名</p><ul><li><code>quit</code></li><li><code>exit</code></li><li><code>\q</code></li></ul><h3 id="1-4-1-连接注意事项"><a href="#1-4-1-连接注意事项" class="headerlink" title="1.4.1 连接注意事项"></a>1.4.1 连接注意事项</h3><ul><li>最好不要在一行命令中输入密码<br>（保护密码不显示）</li><li>在一行命令中输入密码 -p和密码之间不能有空白字符</li><li>参数顺序无规定</li><li>访问本地客户端不需要-h参数</li><li>省略-u参数，会使用操作系统的用户名进行登录处理</li></ul><h2 id="1-5-客户端与服务器连接的过程"><a href="#1-5-客户端与服务器连接的过程" class="headerlink" title="1.5 客户端与服务器连接的过程"></a>1.5 客户端与服务器连接的过程</h2><p>客户端和服务器连接并发送请求得到响应过程，本质上是一个进程间通信的过程；MySQL支持下面几种通信方式</p><h3 id="1-5-1-TCP-x2F-IP"><a href="#1-5-1-TCP-x2F-IP" class="headerlink" title="1.5.1 TCP&#x2F;IP"></a>1.5.1 TCP&#x2F;IP</h3><p>MySQL采用TCP作为服务器和客户端之间的网络通信协议</p><p>MySQL服务器在启动时默认申请3306端口</p><p>指定端口，使用-P大写的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器指定端口</span></span><br><span class="line">mysqld -P3307</span><br><span class="line"><span class="comment"># 启动客户端程序</span></span><br><span class="line">mysql -h127.0.0.1 -uroot -P3307</span><br></pre></td></tr></table></figure><h3 id="1-5-2-命名管道和共享内存"><a href="#1-5-2-命名管道和共享内存" class="headerlink" title="1.5.2 命名管道和共享内存"></a>1.5.2 命名管道和共享内存</h3><p>使用Windows进行通信，通过添加参数使用命名管道和共享内存</p><p>注意的是，共享内存的通信服务器进程和客户端进程必须位于同一台主机</p><ul><li>命名管道<br>在服务器加上 –enable-named-pipe参数<br>在客户端加上 –pipi或者 –protocol&#x3D;pipe参数</li><li>共享内存<br>在服务器加上–shared-memory参数<br>在客户端加上–protocol&#x3D;memory参数</li></ul><h3 id="1-5-3-UNIX域套接字"><a href="#1-5-3-UNIX域套接字" class="headerlink" title="1.5.3 UNIX域套接字"></a>1.5.3 UNIX域套接字</h3><p>&#x2F;&#x2F; 略</p><h2 id="1-6-服务器处理客户端请求"><a href="#1-6-服务器处理客户端请求" class="headerlink" title="1.6 服务器处理客户端请求"></a>1.6 服务器处理客户端请求</h2><p>查询请求流程图</p><p><img src="/xkond/2022/07/17/2022-07-17%20%E5%88%9D%E8%AF%86MySQL/Snipaste_2022-07-17_15-50-32.png"></p><h3 id="1-6-1-连接管理"><a href="#1-6-1-连接管理" class="headerlink" title="1.6.1 连接管理"></a>1.6.1 连接管理</h3><p>每次客户端进程请求连接到服务器进程时候，服务器进程会创建一个线程与该客户端处理</p><p>当断开连接之后，这个线程不会马上被销毁，而是缓存起来，另一个新的客户端进来再将线程分配给新客户端，节省了创建和销毁线程的开销</p><p>同时，如果线程被分配的太多，会影响整体的性能，需要对可连接的客户端进行限制</p><p>建立连接时，客户端会携带主机信息、用户名、密码等信息，服务器对于这些信息进行验证</p><h3 id="1-6-2-解析与优化"><a href="#1-6-2-解析与优化" class="headerlink" title="1.6.2 解析与优化"></a>1.6.2 解析与优化</h3><p>解析客户端发过来的文本请求</p><ol><li><p>查询缓存<br>同样的请求通过缓存直接查找结果</p><blockquote><p>tag: 因为维护缓存的开销，从5.7.20后不推荐使用，8.0直接删除</p></blockquote></li><li><p>语法解析<br>类似于程序的语法编译解析过程，</p></li><li><p>查询优化<br>对查询过程的优化</p></li></ol><h3 id="1-6-3-存储引擎"><a href="#1-6-3-存储引擎" class="headerlink" title="1.6.3 存储引擎"></a>1.6.3 存储引擎</h3><p>存储引擎负责对表中的数据进行读取和写入工作</p><p>根据不同存储引擎调用接口获取数据</p><h2 id="1-7-常用存储引擎"><a href="#1-7-常用存储引擎" class="headerlink" title="1.7 常用存储引擎"></a>1.7 常用存储引擎</h2><p>目前常用的存储引擎就是InnoDB和MyISAM，偶尔MEMORY。InnoDB是MySQL的默认存储引擎</p><p>不同的存储引擎支持不同的功能</p><blockquote><p>tag: 5.5.5版本之前默认存储引擎是MyISAM</p></blockquote><h2 id="1-8-关于存储引擎的一些操作"><a href="#1-8-关于存储引擎的一些操作" class="headerlink" title="1.8 关于存储引擎的一些操作"></a>1.8 关于存储引擎的一些操作</h2><h3 id="1-8-1-查看当前服务器程序支持的存储引擎"><a href="#1-8-1-查看当前服务器程序支持的存储引擎" class="headerlink" title="1.8.1 查看当前服务器程序支持的存储引擎"></a>1.8.1 查看当前服务器程序支持的存储引擎</h3><p>查看服务器程序支持的存储引擎</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINES<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Support列表示存储引擎是否可用</p><p>DEFAULT代表服务器默认引擎</p><p>Comment是对存储引擎的描述</p><p>Transactions列代表该引擎是否支持事务处理</p><p>XA代表引擎是否支持分布式事务</p><p>Savepoints代表该存储引擎是否支持事务的部分回滚</p><h3 id="1-8-2-设置表的存储引擎"><a href="#1-8-2-设置表的存储引擎" class="headerlink" title="1.8.2 设置表的存储引擎"></a>1.8.2 设置表的存储引擎</h3><p>可以设置不同的表为不同的存储引擎；也就是说，不同的表可以有不同的物理存储结构、不同的读取和写入方式。</p><ol><li><p>创建表时指定存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 （</span><br><span class="line">    建表语句</span><br><span class="line">）ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure></li><li><p>修改表的存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINe <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure></li></ol><p>查看表结构</p><p><code>SHOW CREATE TABLE 表名</code></p><h1 id="CH2-MySQL的调控按钮——启动选项和系统变量"><a href="#CH2-MySQL的调控按钮——启动选项和系统变量" class="headerlink" title="CH2 MySQL的调控按钮——启动选项和系统变量"></a>CH2 MySQL的调控按钮——启动选项和系统变量</h1><h2 id="2-1-启动选项和配置文件"><a href="#2-1-启动选项和配置文件" class="headerlink" title="2.1 启动选项和配置文件"></a>2.1 启动选项和配置文件</h2><p>通过修改程序启动时候的命令，或者在配置文件中修改，对于MySQL的功能或者运行选项进行修改</p><h3 id="2-1-1-在命令行使用选项"><a href="#2-1-1-在命令行使用选项" class="headerlink" title="2.1.1 在命令行使用选项"></a>2.1.1 在命令行使用选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁止客户端使用TCP/IP进行通信</span></span><br><span class="line">mysqld --skip-networking</span><br><span class="line"><span class="comment"># 等价 mysql --skip_networking</span></span><br><span class="line"><span class="comment"># 使用 -h指定主机会失败</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认存储引擎</span></span><br><span class="line">mysqld --default-storage-engine=MyISAM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用命令形式</span></span><br><span class="line">--启动选项1[=值1] --启动选项2[=值2] ... --启动选项n[=值n]</span><br><span class="line"></span><br><span class="line">mysql --<span class="built_in">help</span>  <span class="comment"># 查看启动选项</span></span><br></pre></td></tr></table></figure><p>选项的长形式和短形式</p><table><thead><tr><th>长形式</th><th>短形式</th><th>含义</th></tr></thead><tbody><tr><td>–host</td><td>-h</td><td>主机名</td></tr><tr><td>–user</td><td>-u</td><td>用户名</td></tr><tr><td>–password</td><td>-p</td><td>密码</td></tr><tr><td>–port</td><td>-P</td><td>端口</td></tr><tr><td>–version</td><td>-v</td><td>版本信息</td></tr></tbody></table><h3 id="2-1-2-配置文件中使用选项"><a href="#2-1-2-配置文件中使用选项" class="headerlink" title="2.1.2 配置文件中使用选项"></a>2.1.2 配置文件中使用选项</h3><p>避免每次重新启动都需要加载启动选项，推荐使用配置文件方式设置启动选项</p><ol><li><p>配置文件路径</p><p>MySQL程序会在多个路径下寻找配置文件</p><blockquote><p>Windows下：略</p><p>类UNIX操作系统下：</p><table><thead><tr><th>路径名</th><th>备注</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;my.cnf</td><td></td></tr><tr><td>&#x2F;etc&#x2F;mysql&#x2F;my.cnf</td><td></td></tr><tr><td>SYSCONFDIR&#x2F;my.cnf</td><td></td></tr><tr><td>$MYSQL_HOME&#x2F;my.cnf</td><td>特定于服务器的选项（仅限服务器）</td></tr><tr><td>defaults-extra-file</td><td>命令行指定的额外配置文件路径</td></tr><tr><td>~&#x2F;.my.cnf</td><td>特定于用户的选项</td></tr><tr><td>~&#x2F;.mylogin.cnf</td><td>特定于用户的登录路径选项（仅限客户端）</td></tr></tbody></table></blockquote></li><li><p>配置文件内容</p><p>[server]和[mysqld]等对应不同的选项组中的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line"><span class="comment"># 所有服务器程序</span></span><br><span class="line"><span class="comment"># 具体启动选项</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line"><span class="comment"># 能读取的组:[mysqld]、[server]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line"><span class="comment"># 能读取的组:[mysqld]、[server]、[mysqld_safe]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysql.server]</span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line"><span class="comment"># 能读取的组:[mysqld]、[server]、[mysql.server]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 所有的客户端程序</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line"><span class="comment"># 能读取的组:[mysql]、[client]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysqladmin]</span><br><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line"><span class="comment"># 能读取的组:[mysqladmin]、[client]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line"><span class="comment"># 能读取的组:[mysqldump]、[client]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>特定版本专用组<br>可以定义一个[mysqld-5.7]选项组，只有版本号为5.7的mysqld程序才能使用该选项组中的选项</p></li><li><p>配置文件的优先级</p><p>按照1中的表格顺序读取配置<br>如果存在配置文件中有冲突的启动选项，则以最后一个配置文件中的文件为准</p></li><li><p>同一个配置文件中多个组的优先级<br>一份文件中出现读取多个组中存在重复的启动选项，以最后一个组中出现的启动选项为准</p></li><li><p>defaults-file的使用</p><p>指定配置文件进行启动，使用以下命令</p><p><code>mysqld  --defaults-file=/tmp/myconfig.txt</code></p><blockquote><p> 另外还有 defaults-extra-file，可以指定额外的配置文件，同时包括原有的配置文件</p></blockquote></li><li><p>如果在命令行中和配置文件中存在冲突的启动选项，以命令行中的启动选项为准</p></li></ol><h2 id="2-2-系统变量"><a href="#2-2-系统变量" class="headerlink" title="2.2 系统变量"></a>2.2 系统变量</h2><h3 id="2-2-1-系统变量简介"><a href="#2-2-1-系统变量简介" class="headerlink" title="2.2.1 系统变量简介"></a>2.2.1 系统变量简介</h3><p>MySQL服务器程序在运行过程中会用到许多影响程序行为的变量，被称为系统变量</p><ul><li>允许同时连入的客户端 <code>max_connections</code></li><li>表的默认引擎<code>default_storage_engine</code></li><li>查询缓存的大小<code>query_cache_size</code></li></ul><p>MySQL服务器程序的系统变量有几百个，每个系统变量都有默认值</p><p>系统变量值可以通过命令行或者配置文件在启动时修修改</p><p>大多数系统变量值可以在程序运行过程中修改，无须重启服务器</p><h3 id="2-2-2-查看系统变量"><a href="#2-2-2-查看系统变量" class="headerlink" title="2.2.2 查看系统变量"></a>2.2.2 查看系统变量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES [<span class="keyword">LIKE</span> 匹配模式]</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;default%&#x27;</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;max_connections&#x27;</span> <span class="comment">-- 查看最大连接数</span></span><br></pre></td></tr></table></figure><h3 id="2-2-3-设置系统变量"><a href="#2-2-3-设置系统变量" class="headerlink" title="2.2.3 设置系统变量"></a>2.2.3 设置系统变量</h3><ol><li><p>通过启动选项</p><ul><li><p>通过命令行添加启动选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --default-storage-engine=MyISAM --max-connection=10</span><br></pre></td></tr></table></figure></li><li><p>通过配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=MyISAM</span><br><span class="line">max-connection=10</span><br></pre></td></tr></table></figure></li></ul></li><li><p>服务器运行过程中设置</p><ol><li><p>设置不同范围的系统变量</p><p>因为多个客户端可以连接到同一个服务器，对于同一个系统变量，有时想要让不同的客户端有不同的值。</p><p>面临两个问题：</p><ol><li>一些系统变量不是面向单个客户端的，如连接数量max_connections、缓存大小query_cache_size</li><li>新客户端连接到服务器是，对应的系统变量如何设置</li></ol><p>解决方案，通过系统变量的范围概念进行控制</p><ol><li>GLOBAL（全局范围）：影响服务器的整体操作，具有GLOBAL作用范围的系统变量称为全局变量</li><li>SESSION（会话范围）：影响某一个客户端连接的操作，具有SESSION作用范围的系统变量可以称为会话变量</li></ol><p>服务器启动时，将所有全局变量设置</p><p>每个连接的客户端维护一组会话变量，客户端的回话变量是在连接时使用全局变量的当前值进行初始化。</p><blockquote><p>通过客户端设定系统变量的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] 系统变量名 = 值;</span><br><span class="line">或者</span><br><span class="line">SET [@@(GLOBAL|SESSION).] 系统变量名 = 值;</span><br><span class="line"></span><br><span class="line">SET SESSION default_storage_engine = MyISAM;</span><br></pre></td></tr></table></figure><p>注意：如果没有GLOAL修饰符，则默认是SESSION</p></blockquote></li><li><p>查看不同作用范围的系统变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配模式];</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>不是所有系统变量都有GLOBAL和SESSION作用范围<ul><li>例如max_connections，只有GLOBAL范围</li><li>insert_id，表示只具有SESSION作用范围，它表示在对某个包含AUTO__INCREMENT列的表进行插入时，该列的初始值</li><li>其余大部分系统变量都是具有两种作用范围的</li></ul></li><li>有些系统变量是只读<ul><li>version，表示版本</li></ul></li></ul></li></ol></li><li><p>启动选项和系统变量的区别：</p><ul><li>大部分系统变量可以通过启动选项传入</li><li>部分系统变量是自行生成的，不可以当做启动选项</li><li>某些启动选项不是系统变量，如defaults-file</li></ul></li></ol><h2 id="2-3-状态变量"><a href="#2-3-状态变量" class="headerlink" title="2.3 状态变量"></a>2.3 状态变量</h2><p>状态是用来显示服务器程序运行状态的，并且只能查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS [<span class="keyword">LIKE</span> 匹配模式]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 《MySQL是怎样运行的》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/15/hello-world/"/>
      <url>/2022/07/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的blog，这是一个技术和随想分享的博客</p><p>Welcome to my blog, my name is XKond, a Back-End Enginer working with Python &amp; Node.js .</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
